<?xml version="1.0" encoding="utf-8"?>
<references xmlns="https://github.com/dfan97" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="https://github.com/dfan97 ../Xsd/common.xsd">
  <reference type="{effect}">
  	<choice min="1" max="*">
      
      
      
      
      <complex entity="abort_special_project" scope="country">
        <annotation>Aborts a specific special project for the country, removing it from the situation log</annotation>
      	
      	<simple entity="type" type="{project}" min="1" />
      	<simple entity="location" type="{?}" min="1" />
      </complex>
      <simple entity="activate_crisis_progression" type="{bool}" scope="country">
        <annotation>Activates crisis progression for the country</annotation>
      </simple>
      <simple entity="activate_gateway" type="{target}">
        <annotation>Activates the gateway associated with a megastructure</annotation>
      </simple>
      <complex entity="activate_saved_leader" scope="country">
        <annotation>Moves a saved leader to the active for the scoped country with a lookup key</annotation>
        <!--activate_saved_leader = {
	key = <string>
	add_to_owned=<yes/no> #default yes
	effect = {...}
}-->
      </complex>
      <complex entity="add_anomaly">
        <annotation>Adds a specific anomaly category to the scoped planet</annotation>
        <!--add_anomaly = {
	category = <key>
	target = target:country }-->
      </complex>
      <complex entity="add_associate_member" scope="federation">
        <annotation>Add specified country as an associate member</annotation>
        <!--add_associate_member = { who = <target> override_requirements = yes/no }-->
      </complex>
      <complex entity="add_asteroid_belt" scope="galactic_object">
        <annotation>Adds an asteroid belt at the distance in the scope</annotation>
        <!--Example:
add_asteroid_belt = {
	radius=<desired radius>
	type=<asteroid belt type key>
}-->
      </complex>
      <complex entity="add_blocker" scope="planet">
        <annotation>Adds a blocker to a planet, with some control over what it is set to block (add_deposit will add a random planetary deposit to block)</annotation>
        <!--add_blocker = {
	type = <key>
	blocked_deposit = none (default)/<deposit scope - copies the type to the blocked deposit but any flags or variables are lost>/random
}-->
      </complex>
      <simple entity="add_building" type="{key}" scope="planet">
        <annotation>Begins construction of a specific building on the scoped planet</annotation>
      </simple>
      <complex entity="add_casus_belli" scope="country">
        <annotation>Adds a Casus Belli to the scoped country against the target country</annotation>
        <!--add_casus_belli = { type = cb_subjugation who = <country> days = 10/variable }-->
      </complex>
      <complex entity="add_claims" scope="galactic_object">
        <annotation>Adds claims on target system</annotation>
        <!--add_claims = { who = <country> num_of_claims = x show_notification = no }-->
      </complex>
      <simple entity="add_cohesion" type="{value}" scope="federation">
        <annotation>Add cohesion to the federation</annotation>
      </simple>
      <simple entity="add_colony_progress" type="{0.0-1.0}" scope="planet">
        <annotation>Adds to ongoing colonization progress on the scoped planet</annotation>
      </simple>
      <simple entity="add_custodian_term_days" type="{days}">
        <annotation>Increase the current Custodian term time</annotation>
      </simple>
      <simple entity="add_deposit" type="{key/random}" scope="planet">
        <annotation>Adds resource deposit to the scoped planet (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)</annotation>
      </simple>
      <simple entity="add_district" type="{key}" scope="planet">
        <annotation>Begins construction of a specific district on the scoped planet</annotation>
      </simple>
      <simple entity="add_espionage_information" type="{value}" scope="espionage_operation">
        <annotation>Adds information to the current stage of an espionage operation</annotation>
      </simple>
      <complex entity="add_event_chain_counter" scope="country">
        <annotation>Increments (or decrements with negative values) an event chain counter for the scoped country by a specific amount</annotation>
        <!--add_event_chain_counter = { event_chain = <key> counter = <key> amount = <int>/<variable> }-->
      </complex>
      <simple entity="add_expedition_log_entry" type="{int}" scope="archaeological_site">
        <annotation>Adds clues to the current stage of a archaeological site</annotation>
      </simple>
      <simple entity="add_experience" type="{int}" scope="leader">
        <annotation>Adds a sum of experience points to the scoped leader</annotation>
      </simple>
      <simple entity="add_favors" type="{target value = 2/variable }}" scope="country">
        <annotation>Add &lt;value&gt; favors for scoped country to use on target country. add_favor = {</annotation>
      </simple>
      <simple entity="add_federation_experience" type="{federation experience}" scope="federation">
        <annotation>Adds experience to the scoped federation</annotation>
      </simple>
      <simple entity="add_global_ship_design" type="{target}">
        <annotation>Adds a specific global design to the game</annotation>
      </simple>
      <complex entity="add_hyperlane">
        <annotation>Adds a hyperlane between two systems</annotation>
        <!--add_hyperlane = { from = <system> to = <system> }-->
      </complex>
      <simple entity="add_imperial_authority" type="{value}">
        <annotation>Add imperial_authority</annotation>
      </simple>
      <simple entity="add_intel" scope="country">
        <annotation>Adds the defined amount of intel toward the target empire add_intel = { amount = &lt;float&gt;/&lt;variable&gt; who = &lt;target&gt; }</annotation>
      </simple>
      <complex entity="add_intel_report" scope="country">
        <annotation>Adds the intel level for the category selected. Default duration (0) is forever</annotation>
        <!--add_intel_report = { category = <string> level = <int> days = <int> who = <target> }-->
      </complex>
      <simple entity="add_mission_progress" type="{+/- float}" scope="fleet">
        <annotation>Adds or subtracts progress to/from the scoped observation post's current mission</annotation>
      </simple>
      <complex entity="add_modifier" scope="country espionage_operation federation fleet galactic_object megastructure planet pop pop_faction ship spy_network">
        <annotation>Adds a specific modifier to the scoped object for a set duration</annotation>
        <!--add_modifier = {
	modifier = <key>
	days/months/years = <int, -1 (default) means it never expires>
	multiplier = <float>/<variable> (optional)
	time_multiplier = <variable> (optional: days/months/years value is multiplied by the value of this variable)
	clear_on_owner_change = yes (optional: default no; clears modifier if planet/system/megastructure's owner changes)
}-->
      </complex>
      <complex entity="add_monthly_resource_mult" scope="country">
        <annotation>Adds a lump sum of a resource to the scoped country, defined as a multiple of the country's monthly income of that resource (clamped to max and min allowed values)</annotation>
        <!--add_monthly_resource_mult = { resource = <key> value = <multiplier, float> max = <max cap, int> min = <min cap, int> }-->
      </complex>
      <simple entity="add_notification_modifier" type="{key}" scope="country">
        <annotation>Add a notification modifier to the country</annotation>
      </simple>
      <complex entity="add_opinion_modifier" scope="country">
        <annotation>Adds a specific opinion modifier for the scoped country towards target country</annotation>
        <!--add_opinion_modifier = { modifier = <key> who = <target> }-->
      </complex>
      <simple entity="add_permanent_councillor" type="{bool}" scope="country">
        <annotation>Gives provided country a permanent position on the Galactic Council</annotation>
      </simple>
      <simple entity="add_planet_devastation" type="{int}" scope="planet">
        <annotation>Instantly adds devastation to scoped planet</annotation>
      </simple>
      <simple entity="add_random_non_blocker_deposit" type="{bool}" scope="planet">
        <annotation>Adds random non-blocker resource deposit to the scoped planet</annotation>
      </simple>
      <complex entity="add_random_research_option" scope="country">
        <annotation>Adds s random tech research option to the scoped country's tech view list, permanent until researched. if none applicable it runs fail_effects</annotation>
        <!--add_random_research_option = {
	category = <string>
	area = <key>
	tier = <int>
	add_progress = <num>/<variable>
	ignore_prereqs = <yes/no> #default no
	ignore_rare = <yes/no> #default yes
	fail_effects = {}
}-->
      </complex>
      <simple entity="add_relic" scope="country">
        <annotation>Adds the specified relic to the scoped country. add_relic = &lt;relic_key&gt;</annotation>
      </simple>
      <simple entity="add_research_option" type="{key}" scope="country">
        <annotation>Adds a tech research option to the scoped country's tech view list, permanent until researched</annotation>
      </simple>
      <complex entity="add_resource" scope="country">
        <annotation>Adds specific resource to the stockpile for the country scope</annotation>
        <!--add_resource = {
	<resource_name_1> = <value_1>
	<resource_name_2> = <value_2>
	...
	mult = <variable> (optional: multiplies all gained resources by a variable)
}-->
      </complex>
      <simple entity="add_ruler_trait" type="{trait}" scope="leader">
        <annotation>Adds a specific ruler trait to the scoped leader, even if they are not currently ruler; it becomes active when they become ruler</annotation>
      </simple>
      <simple entity="add_seen_bypass" type="{FROM}" scope="country">
        <annotation>Makes the scoped country remember that it has encountered the bypass</annotation>
      </simple>
      <simple entity="add_seen_bypass_type" type="{bypass_type}" scope="country">
        <annotation>Makes the scoped country remember that it has encountered the bypass type</annotation>
      </simple>
      <simple entity="add_ship_design" type="{target}" scope="country">
        <annotation>Adds a specific ship design to the scoped country</annotation>
      </simple>
      <simple entity="add_situation_progress" type="{float}" scope="situation">
        <annotation>Adds a sum of progress scoped situation</annotation>
      </simple>
      <simple entity="add_skill" type="{int}" scope="leader">
        <annotation>Adds to the scoped leader's skill level</annotation>
      </simple>
      <simple entity="add_spy_network_level" type="{int}" scope="spy_network">
        <annotation>Adds levels to the current Spy Network</annotation>
      </simple>
      <simple entity="add_stage_clues" type="{int}" scope="archaeological_site first_contact">
        <annotation>Adds clues to the current stage of an archaeological or first contact site</annotation>
      </simple>
      <complex entity="add_stage_modifier" scope="espionage_operation">
        <annotation>Adds a specific modifier to the current espionage operation stage for a set duration or until stage is changed</annotation>
        <!--add_stage_modifier = { modifier = <key> days = <int, -1 means it never expires> }-->
      </complex>
      <complex entity="add_static_war_exhaustion" scope="country">
        <annotation>Adds static war exhaustion, scaled with value_for_planet_destruction, to owner of the battle location</annotation>
        <!--add_static_war_exhaustion = {
	attacker = <country>
	location = <planet> 
	value_for_planet_destruction = <0.0-1.0>/<variable> #scales the amount of war exhaustion that is added
}-->
      </complex>
      <complex entity="add_tech_progress" scope="country">
        <annotation>Gives percentage progress (0.0-1.0) in a specific tech to the scoped country</annotation>
        <!--add_tech_progress = { tech = <key> progress = <float>/<variable> }-->
      </complex>
      <complex entity="add_threat" scope="country galactic_object planet">
        <annotation>Adds diplomatic threat from target country</annotation>
        <!--add_threat = { who = <country> amount = 4/variable }-->
      </complex>
      <complex entity="add_timed_trait" scope="leader">
        <annotation>Adds a specific trait to the scoped leader for a specific duration</annotation>
        <!--add_timed_trait = { trait = <trait> days/months/years = <value>/<variable> }-->
      </complex>
      <simple entity="add_to_galactic_community" type="{bool}" scope="country">
        <annotation>Tries to add the scoped country to the Galactic Community</annotation>
      </simple>
      <simple entity="add_to_galactic_community_no_message" type="{bool}" scope="country">
        <annotation>Tries to add the scoped country to the Galactic Community without producing member joining notifications</annotation>
      </simple>
      <simple entity="add_to_galactic_council" type="{bool}" scope="country">
        <annotation>Tries to add the scoped country to the Galactic Council</annotation>
      </simple>
      <simple entity="add_tradition" scope="country">
        <annotation>Adds the specified tradition to the scoped country. add_tradition = &lt;tradition_key&gt;</annotation>
      </simple>
      <simple entity="add_trait" type="{trait}" scope="leader">
        <annotation>Adds a specific trait to the scoped leader</annotation>
      </simple>
      <complex entity="add_trust" scope="country">
        <annotation>Adds trust on scope country towards target country</annotation>
        <!--add_trust = { amount = <amount>/<variable> who = <target> }-->
      </complex>
      <complex entity="add_victory_score" scope="country">
        <annotation>Adds victory score to a country</annotation>
        <!--add_victory_score = { source=<loc_key> score=<value>/<variable> }-->
      </complex>
      <simple entity="assign_espionage_asset" type="{esspionage asset type}" scope="espionage_operation">
        <annotation>Assigns espionage asset to the scope operation from owning spy network</annotation>
      </simple>
      <simple entity="assign_leader" type="{target}" scope="army country fleet pop_faction sector">
        <annotation>Assigns target leader to the scoped country/fleet/army/pop faction/sector</annotation>
      </simple>
      <complex entity="auto_follow_fleet" scope="fleet ship">
        <annotation>Makes a fleet or ship auto-move to target fleet and potentially attack it</annotation>
        <!--auto_follow_fleet = { target = <fleet> attack_fleet = yes }-->
      </complex>
      <complex entity="auto_move_to_planet" scope="fleet ship">
        <annotation>Makes a fleet or ship auto-move to target planet</annotation>
        <!--auto_move_to_planet = { target = <planet> clear_auto_move_on_arrival = yes }-->
      </complex>
      
      
      
      
      <complex entity="begin_event_chain">
        <annotation>Starts a situation log event chain for target country</annotation>
        <!--begin_event_chain = { event_chain = <key> target = <target> }-->
      </complex>
      <simple entity="break" type="{bool}">
        <annotation>Prevents execution of subsequent effects in the same effect block, used with if-statements</annotation>
      </simple>
      
      
      
      
      <simple entity="calculate_modifier" type="{bool}" scope="planet">
        <annotation>Forces target planet or country to calculate its internal modifier</annotation>
      </simple>
      <simple entity="cancel_resolution" type="{resolution type}" scope="country">
        <annotation>Immediately cancels/removes the latest active/passed/proposed/voting for/failed resolution of this type</annotation>
      </simple>
      <simple entity="cancel_terraformation" type="{bool}" scope="planet">
        <annotation>Cancels terraformation of the scoped planet</annotation>
      </simple>
      <simple entity="ceiling_variable" type="{string}" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Rounds a previously-set variable up to the next integer</annotation>
      </simple>
      <simple entity="change_colony_foundation_date" type="{+/- int}" scope="planet">
        <annotation>Changes the colony foundation date (affecting on_colony_X_years pulses) by a specific number of days. Use with care, you can probably break things with this!</annotation>
      </simple>
      <complex entity="change_country_flag" scope="country">
        <annotation>Changes the scoped country's flag</annotation>
        <!--change_country_flag = random
change_country_flag = { icon = { category = <key> file = <filename> } background = { category = <key> file = <filename> } colors = { <key> <key> } }-->
      </complex>
      <complex entity="change_dominant_species" scope="country">
        <annotation>Changes the dominant species of the current Country, change_all also changes all usage of that species (Pops etc) in the empire</annotation>
        <!--change_dominant_species = { species = target change_all = yes }-->
      </complex>
      <complex entity="change_government" scope="country">
        <annotation>Change the scoped country's government authority and/or civics</annotation>
        <!--change_government = random
or
change_government = {
	authority = random / <key>
	civics = random / { civic = <key> civic = random }
cooldown = no (default: yes)
remove_invalid_civics = yes (default: no)
}-->
      </complex>
      <simple entity="change_leader_portrait" type="{key or species event target}" scope="leader">
        <annotation>Changes the portrait of the leader in scope</annotation>
      </simple>
      <complex entity="change_pc" scope="planet">
        <annotation>Changes the class of the scoped planet</annotation>
        <!--change_pc = <class/random list>
change_pc = { class = <class/random list> inherit_entity = yes }-->
      </complex>
      <simple entity="change_planet_size" type="{+/- int}" scope="planet">
        <annotation>Increases or reduces the size of the scoped planet by a specified amount</annotation>
      </simple>
      <simple entity="change_species" type="{target}" scope="army country leader pop ship">
        <annotation>Changes the species of the scoped object</annotation>
      </simple>
      <complex entity="change_species_characteristics" scope="species">
        <annotation>Changes the characteristics of a species</annotation>
        <!--change_species_characteristics = {
	sapient = <Y/N, determines if species is pre-sapient>
	immortal = <Y/N, determines if species leaders are immortal>
	can_be_modified = <Y/N, determines if the species can be modified>
	add_trait = <key> # optional, can specify multiple
	remove_trait = <key> # optional, can specify multiple
	add_traits_at_start_of_list = yes # optional, pushes out other traits if needed
	portrait = <key/species/leader event target, limits >
	gender = <any/male/female/leader event target, limits species to this gender or removes limit if 'any'>
	can_change_leader = <Y/N, apply portrait and gender (randomizes new name) changes to existing leaders>-->
      </complex>
      <simple entity="change_species_portrait" type="{key or species event target}" scope="species">
        <annotation>Changes the portrait of the species in scope</annotation>
      </simple>
      <complex entity="change_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Increments a previously-set variable by a specific amount</annotation>
        <!--change_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }-->
      </complex>
      <complex entity="check_casus_belli_valid" scope="country">
        <annotation>Re-evaluate the specified casus belli type with given target country</annotation>
        <!--check_casus_belli_valid = {
	target = none/<optional country target>
	type = <optional casus belli type>
}-->
      </complex>
      <simple entity="check_planet_employment" type="{bool}" scope="planet">
        <annotation>Immediately runs a job evaluation on the planet, firing and employing pops as needed</annotation>
      </simple>
      <simple entity="clear_blocker" type="{bool}" scope="deposit">
        <annotation>Clears scoped deposit blocker and fires its on_cleared effect</annotation>
      </simple>
      <simple entity="clear_blockers" type="{bool}" scope="planet">
        <annotation>Removes all blockers from the scoped planet</annotation>
      </simple>
      <simple entity="clear_custom_ruler_and_heir_titles" type="{bool}" scope="country">
        <annotation>Clears all custom ruler and heir titles from the country, resetting them to default values</annotation>
      </simple>
      <simple entity="clear_deposits" type="{bool}" scope="planet">
        <annotation>Removes all deposits from the scoped planet</annotation>
      </simple>
      <simple entity="clear_ethos" type="{bool}" scope="country pop">
        <annotation>Clears all ethics of specified pop or country</annotation>
      </simple>
      <simple entity="clear_fleet_actions" type="{target}" scope="fleet">
        <annotation>Clears all queued fleet actions for target fleet</annotation>
      </simple>
      <simple entity="clear_global_event_target" type="{string}">
        <annotation>Deletes the specified saved global target reference</annotation>
      </simple>
      <simple entity="clear_global_event_targets" type="{bool}">
        <annotation>Deletes all saved global target references</annotation>
      </simple>
      <complex entity="clear_intel_report" scope="country">
        <annotation>Removes all the intel reports related to the provided category</annotation>
        <!--clear_intel_report = { category = <string> who = <target> }-->
      </complex>
      <simple entity="clear_orders" type="{bool}" scope="fleet">
        <annotation>Clears all fleet orders from the scoped fleet</annotation>
      </simple>
      <simple entity="clear_planet_modifiers" type="{bool}" scope="planet">
        <annotation>Clear modifiers on target planet</annotation>
      </simple>
      <simple entity="clear_pop_category" type="{bool}" scope="pop">
        <annotation>Resets category of a pop</annotation>
      </simple>
      <simple entity="clear_resources" type="{bool}" scope="country">
        <annotation>Clears resources of a country</annotation>
      </simple>
      <simple entity="clear_uncharted_space" type="{target}" scope="country">
        <annotation>Clears uncharted space from the galaxy map for the scoped country, in a radius around target system</annotation>
      </simple>
      <simple entity="clear_variable" type="{string}" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Clears a previously-set variable from the game</annotation>
      </simple>
      <complex entity="clone_leader" scope="country">
        <annotation>Clones the last created leader for the scoped country</annotation>
        <!--clone_leader = {
	target = <event target>
	#properties to override, see create_leader
	effect = { ... }
}-->
      </complex>
      <simple entity="close_branch_office" type="{bool}" scope="planet">
        <annotation>Close branch office on scoped planet</annotation>
      </simple>
      <complex entity="closest_system">
        <annotation>Executes enclosed effects on a system -within a specific number of jumps span- that meets the limit criteria. This completely ignores bypasses (wormholes and gateways)</annotation>
        <!--closest_system = {
	min_steps = <int, minimum # of systems 'away'>
	max_steps = <int, maximum # of systems 'away'>
	use_bypasses = yes/no (default: no)
	limit = { <complex sequence="only" type="{trigger}" /> }
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <simple entity="complete_crisis_objective" type="{objective}" scope="country">
        <annotation>Gives the player the reward for the specified crisis objective</annotation>
      </simple>
      <complex entity="complete_special_project" scope="country">
        <annotation>Completes a specific special project for the country, firing the on complete effects</annotation>
        <!--complete_special_project = { type = <project key> location = <target> }-->
      </complex>
      <simple entity="complete_tutorial_step">
        <annotation>Create and sends an telemetry event keeping track of the tutorial steps for the current game</annotation>
      </simple>
      <simple entity="conquer" type="{target country}" scope="planet">
        <annotation>Conquers the planet by setting its owner to target country and adding an unhappiness modifier</annotation>
      </simple>
      <simple entity="copy_ethos_and_authority" type="{FROM}" scope="country">
        <annotation>Makes the scoped country copy the ethos and government authority of the target country</annotation>
      </simple>
      <complex entity="copy_random_tech_from" scope="country">
        <annotation>Adds a random tech from the target country within the given category and tech area constraints. The country must be able to research said tech (weight &gt; 0, fulfils potential trigger)</annotation>
        <!--copy_random_tech_from = {
	who = <country>
	category = computing (optional)
	area = physics (optional)
	progress = 0.5/variable (optional: this makes it grant the tech option rather than the whole tech)
}-->
      </complex>
      <complex entity="copy_techs_from" scope="country">
        <annotation>Copies all techs from the target country to the scoped country, except for some exceptions listed. Tech weights (and weight modifiers) are honoured, meaning that techs a country should not have will not be copied</annotation>
        <!--copy_techs_from = { 
	target = country
	except = { tech_1 tech_2 }
}-->
      </complex>
      <simple entity="country_add_ethic" type="{key}" scope="country">
        <annotation>Adds a specific ethic to the scoped country</annotation>
      </simple>
      <complex entity="country_event" scope="country">
        <annotation>Fires a country event for the scoped country, with optional DAYS and RANDOM delay</annotation>
        <!--country_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="country_list_tooltip">
        <annotation>Prints a list of the countries that match the limit triggers in a tooltip, each separated by a line break</annotation>
        <!--country_list_tooltip = { limit = { <complex sequence="only" type="{trigger}" /> } }-->
      </complex>
      <simple entity="country_remove_ethic" type="{key}" scope="country">
        <annotation>Removes a specific ethic from the scoped country</annotation>
      </simple>
      <complex entity="create_ambient_object">
        <annotation>Creates a new ambient object</annotation>
        <!--create_ambient_object = { type = <key> location = <target> }
For VFX use:
create_ambient_object = {
	type = <key>
	scale = <float>
	location = <target>
	use_3d_location = <bool, use 3D entity or 2D coordinate of the location entity as base>
	entity_offset = {
		min = <int>
		max = <int>
	}
	entity_offset_angle = {
		min = <int>
		max = <int>
	}
	entity_offset_height = {
		min = <int>
		max = <int>
	}
	entity_face_object = star/FROM/etc
	entity_scale_to_size = yes/no
	play_animation_once = yes/no
	target = <target>
	duration = <int, days>
}-->
      </complex>
      <simple entity="create_archaeological_site" type="{site type}" scope="ambient_object fleet galactic_object megastructure planet ship starbase">
        <annotation>Creates a archaeological site associated with the scope object</annotation>
      </simple>
      <complex entity="create_army" scope="planet">
        <annotation>Creates a new army</annotation>
        <!--create_army = {
	name = <string>
	owner = <target>
	species = <target>/random
	type = <key>
}-->
      </complex>
      <complex entity="create_army_transport" scope="fleet">
        <annotation>Creates a new army in a new transport ship</annotation>
        <!--create_army_transport = {
	ship_name = <string>
	graphical_culture = <key>
	army_name = <string>
	army_type = <key>
	species = <target>
}-->
      </complex>
      <complex entity="create_bypass" scope="megastructure">
        <annotation>Creates a bypass in the parent SpatialObject (stored in FromFrom), of the type passed in "type"</annotation>
        <!--create_bypass = { owner = <target> type = <bypass type> effect = { <list sequence="only" type="{effect}" /> } }-->
      </complex>
      <complex entity="create_cluster">
        <annotation>Creates a cluster centered around the specified spatial object</annotation>
        <!--create_cluster = {
	id = <some_id>
	center = <system, spatial object>
	radius = 30
}-->
      </complex>
      <complex entity="create_colony" scope="planet">
        <annotation>Creates a colony on the scoped planet</annotation>
        <!--create_colony = {
	owner = <target>
	species = <target / key>
	ethos = <random / target / { ethic = <key> ethic = <key> }>
}-->
      </complex>
      <complex entity="create_country">
        <annotation>Creates a new country</annotation>
        <!--create_country = {
	name = <string/random>
	adjective = <string>
	contact_rule = <string>
 type = <key>
	auto_delete = <bool>
	name_list = <key>
	ship_prefix = <string>
	authority = <key>
	civics = random / { civic = <key> civic = random }
	species = <target>
	flag = <random / { icon = { category = <key> file = <filename.dds> } background = { category = <key> file = <filename.dds> } colors = { <key> <key> } }
	ethos = <random / { ethic = <key> ethic = <key> }>
	restrictions = { <restrictions, see "common\governments\readme_requirements.txt"> }
	effect = { <effects executed on country> }
}-->
      </complex>
      <complex entity="create_espionage_asset" scope="spy_network">
        <annotation>Creates espionage asset within a given spy network</annotation>
        <!--create_espionage_asset = {
	type = <espionage asset type>
	effect = { <effects executed on asset> }
}-->
      </complex>
      <complex entity="create_fleet">
        <annotation>Creates a new fleet</annotation>
        <!--create_fleet = { name = <string> effect = { <create_ship, set_owner, set_location etc effects go here> } }-->
      </complex>
      <complex entity="create_fleet_from_naval_cap" scope="country">
        <annotation>Creates a new fleet from empire designs up to specified fraction of naval cap</annotation>
        <!--create_fleet_from_naval_cap = 0.5
create_fleet_from_naval_cap = { fraction = 0.5 ship_owner_type = <country/federation/galactic_community>-->
      </complex>
      <complex entity="create_half_species">
        <annotation>Creates a new pop from a half-species on the planet</annotation>
        <!--create_half_species = { species_one = <target> species_two = <target> }-->
      </complex>
      <complex entity="create_leader" scope="country">
        <annotation>Creates a new leader for the scoped country</annotation>
        <!--create_leader = {
	name = <random / string>
	species = <target / key>
	gender = <gender> #optional, default = random
	type = <random / key>
	skill = <random / int>
	set_age = <int>
	traits = { trait = <key> trait = <key> }
}-->
      </complex>
      <complex entity="create_message">
        <annotation>Creates a message, can take multiple variables</annotation>
        <!--create_message = { type = BYPASS_EXPLORED localization = BYPASS_EXPLORED_MESSAGE days = 30 target = root variable = { type = name localization = SYSTEM1 scope = from } variable = { type = name localization = SYSTEM2 scope = fromfrom } }-->
      </complex>
      <complex entity="create_military_fleet">
        <annotation>Creates a military fleet with the designs of a specified country</annotation>
        <!--create_military_fleet = { owner = <target> scaled_size = 1.0 effect = { } }-->
      </complex>
      <complex entity="create_mining_station" scope="planet">
        <annotation>Creates a mining station in orbit of the scoped planet</annotation>
        <!--create_mining_station = { owner = <target> }-->
      </complex>
      <complex entity="create_nebula" scope="galactic_object">
        <annotation>Creates a new Nebula with a given radius centered around the current system</annotation>
        <!--create_nebula = {
	name = <name> (loc synced, optional - default is random)
	radius = 100
	effect = { <effects on every system in the new nebula> }
}-->
      </complex>
      <complex entity="create_point_of_interest" scope="country planet pop ship">
        <annotation>Creates a point of interest for the scoped country at a specific location, associated with an event chain</annotation>
        <!--create_point_of_interest = { id = <key> name = <string> desc = <string> event_chain = <key> location = <target> }-->
      </complex>
      <complex entity="create_pop" scope="planet">
        <annotation>Creates a new pop on the scoped planet</annotation>
        <!--create_pop = {
	species = <target / key>
ethos = <random / target / { ethic = <key> ethic = <key> }>
}-->
      </complex>
      <complex entity="create_rebels" scope="planet">
        <annotation>Creates a rebellion</annotation>
        <!--create_rebels = {
	name = <random / string>
	authority = <random / key>
	civics = random / { civic = <key> civic = random }
	species = <target>
	ethos = <random / { ethic = <key> ethic = <key> }
}-->
      </complex>
      <complex entity="create_research_station" scope="planet">
        <annotation>Creates a research station in orbit of the scoped planet</annotation>
        <!--create_research_station = { owner = <target> }-->
      </complex>
      <complex entity="create_saved_leader" scope="country">
        <annotation>Creates a new saved leader for the scoped country with a lookup key</annotation>
        <!--create_saved_leader = {
	key = <string>
	creator = <target>
	name = <random / string>
	species = <target / key>
	gender = <optional / gender> #defalut = random
type = <random / key>
	skill = <random / int>
	set_age = <int>
 traits = { trait = <key> trait = <key> }
}-->
      </complex>
      <complex entity="create_ship" scope="fleet starbase">
        <annotation>Creates a new ship</annotation>
        <!--create_ship = {
	name = <string/random>
	design = <ship design key/target, or use random_existing_design>
	random_existing_design = <ship size key>
	graphical_culture = <graphical culture key>
	prefix = <Y/N, determines if ship name should use owner country prefix>
	colonizer_species = <species, default: fleet owner founder species>
}-->
      </complex>
      <complex entity="create_ship_design">
        <annotation>Creates a new ship design for use with last_created_design target</annotation>
        <!--create_ship_design = { design = <key> ftl = <target, optional, sets FTL drive to target country's> }-->
      </complex>
      <complex entity="create_species">
        <annotation>Creates a new species</annotation>
        <!--create_species = {
	name = <string>/random/scope
	plural = <string>
	class = <species class key>/random/random_non_machine/scope
	portrait = <random/portrait id>
	homeworld = <target>
	traits = { <specific/random traits> }
	sapient = <Y/N, determines if species is pre-sapient>
	is_mod = <Y/N, determines if species is a modification of another>
	immortal = <Y/N, determines if species leaders are immortal>
	can_be_modified = <Y(default)/N/this>
	gender = <species>/male/female/indeterminate/not_set
	clear_parent_species_link = yes/no (default: no)
	allow_negative_traits = yes/no (default: yes)
	namelist = random/random_class/scope
	effect = {}
}-->
      </complex>
      <complex entity="create_starbase" scope="galactic_object">
        <annotation>Creates a starbase in orbit of the star of the scoped galactic object</annotation>
        <!--create_starbase = {
	owner = <target>
	size = <ship_size>
	module = <starbase_module>
	building = <starbase_building>
	effect = { ... }
}-->
      </complex>
      <simple entity="custom_tooltip" type="{string}">
        <annotation>Displays a specific localization string in tooltip</annotation>
      </simple>
      <complex entity="custom_tooltip_with_params">
        <annotation>Displays a specific localization string with parameters in tooltip</annotation>
        <!--custom_tooltip_with_params = {
	description = <loc key>
	description_parameters = {
		<value key> = <string/int/num/bool>
	}
}-->
      </complex>
      
      
      
      
      <simple entity="debug_break" type="{bool}">
        <annotation>Trigger an assertion to stop the debugger when encountering this effect; argument is ignored</annotation>
      </simple>
      <complex entity="declare_war" scope="country">
        <annotation>Declares war between the scoped country and target country</annotation>
        <!--declare_war = {
	target = <target country>
	name = <optional war name>
	attacker_war_goal = <war goal>
}-->
      </complex>
      <simple entity="decrease_council_size" type="{bool}">
        <annotation>Decreases the number of seats on the Galactic Council by 1</annotation>
      </simple>
      <complex entity="delete_fleet">
        <annotation>Deletes the target fleet (no death graphics)</annotation>
        <!--delete_fleet = <target>
delete_fleet = {
	target=<target>
	kill_leader=<yes/no> #default yes
	destroy_template=<yes/no> #default no
}-->
      </complex>
      <simple entity="delete_megastructure" type="{target}">
        <annotation>Deletes the target mega reference (no death graphics)</annotation>
      </simple>
      <simple entity="delete_ship" type="{target}">
        <annotation>Deletes the target ship (no death graphics)</annotation>
      </simple>
      <simple entity="destroy_ambient_object" type="{target}">
        <annotation>Destroys target ambient object</annotation>
      </simple>
      <simple entity="destroy_and_spawn_debris_for" type="{from}" scope="fleet ship">
        <annotation>Sets the current ship or fleet to be destroyed and spawn a debris project for the specified country</annotation>
      </simple>
      <simple entity="destroy_archaeological_site" type="{event target}">
        <annotation>Destroys a archaeological site in right hand site event target</annotation>
      </simple>
      <simple entity="destroy_colony" type="{bool}" scope="planet">
        <annotation>Destroys the colony on the scoped planet</annotation>
      </simple>
      <simple entity="destroy_country" type="{bool}" scope="country">
        <annotation>Destroys the scoped country</annotation>
      </simple>
      <simple entity="destroy_espionage_asset" type="{esspionage asset type}" scope="espionage_operation spy_network">
        <annotation>Destroys espionage asset within a given spy network/operation</annotation>
      </simple>
      <simple entity="destroy_espionage_operation" type="{event target}">
        <annotation>Destroys a espionage operation site in right hand site event target</annotation>
      </simple>
      <complex entity="destroy_fleet">
        <annotation>Destroys the target fleet (with death graphics)</annotation>
        <!--destroy_fleet = <target>
destroy_fleet = {
	target=<target>
	kill_leader=<yes/no> #default yes
	destroy_template=<yes/no> #default no
}-->
      </complex>
      <simple entity="destroy_ship" type="{target}">
        <annotation>Destroys the target ship (with death graphics)</annotation>
      </simple>
      <simple entity="destroy_situation" type="{event target}">
        <annotation>Destroys a situation in right hand side event target, use once situation is complete (on_fail/on_complete/on_abort is not called)</annotation>
      </simple>
      <simple entity="dismantle" type="{bool}" scope="fleet">
        <annotation>Dismantles the scoped orbital station (fleet)</annotation>
      </simple>
      <simple entity="dissolve_federation" type="{bool}" scope="federation">
        <annotation>Dissolved the current federation</annotation>
      </simple>
      <complex entity="divide_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Divides a previously-set variable by a specific amount</annotation>
        <!--divide_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }-->
      </complex>
      <simple entity="downgrade_all_buildings" type="{bool}" scope="country planet">
        <annotation>Downgrades all non-capital buildings on the scoped planet/country. Leaves tier 1 buildings untouched</annotation>
      </simple>
      <simple entity="downgrade_buildings_of_type" type="{bool}" scope="country planet">
        <annotation>Downgrades all buildings of a specified type on the planet/country</annotation>
      </simple>
      
      
      
      
      <complex entity="effect_on_blob" scope="country">
        <annotation>Executes an effect on systems with planets owned by the scoped country, starting at an origin, and until a certain percentage of owned planets matching the planet_limit has been covered</annotation>
        <!--effect_on_blob = {
	center = <system target>
	owned_planets_percentage = 1.0/variable
	planet_limit = { <planet triggers> }
	effect = { <system effects> }
}-->
      </complex>
      <complex entity="else">
        <annotation>Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met</annotation>
        <!--if = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }
else = { <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="else_if">
        <annotation>Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met</annotation>
        <!--if = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }
else_if = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <simple entity="enable_faction_of_type" type="{key}" scope="country">
        <annotation>Forces scoped country to evaluate whether to create a specific faction type immediately, rather than monthly</annotation>
      </simple>
      <simple entity="enable_galactic_market" scope="country">
        <annotation>Enables the galactic market. enable_galactic_market = &lt;yes/no&gt;</annotation>
      </simple>
      <simple entity="enable_on_market" type="{resource_key}">
        <annotation>Enables a resource on the Galactic Market</annotation>
      </simple>
      <complex entity="enable_special_project">
        <annotation>Enables a specific special research project for target country at a specific location (should be same as the current scope where possible)</annotation>
        <!--enable_special_project = { name = <project key> owner = <target, default = root> location = <target, ideally THIS (that is default)> }-->
      </complex>
      <simple entity="end_all_treaties_with" type="{target}" scope="country">
        <annotation>Ends all treaties with the target</annotation>
      </simple>
      <simple entity="end_event_chain" type="{key}" scope="country">
        <annotation>Ends a specific situation log event chain for the scoped country</annotation>
      </simple>
      <simple entity="end_rivalry" type="{target}" scope="country">
        <annotation>Force-end rivalry with target country</annotation>
      </simple>
      <simple entity="end_truce" type="{target}" scope="country">
        <annotation>Force-end truce with target country</annotation>
      </simple>
      <simple entity="endgame_telemetry">
        <annotation>Send endgame telemetry event</annotation>
      </simple>
      <complex entity="espionage_operation_event" scope="espionage_operation">
        <annotation>Fires a espionage event event for the scoped object, with optional DAYS and RANDOM delay</annotation>
        <!--espionage_operation_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <simple entity="establish_branch_office" type="{target}" scope="planet">
        <annotation>Establish branch office on scoped planet for target country</annotation>
      </simple>
      <simple entity="establish_communications" type="{target}" scope="country">
        <annotation>Establish communications between scoped country and target country</annotation>
      </simple>
      <simple entity="establish_communications_no_message" type="{target}" scope="country">
        <annotation>Silently establish communications between scoped country and target country</annotation>
      </simple>
      <complex entity="establish_contact" scope="country">
        <annotation>Establishes first contact between the scoped country and target country at the set location</annotation>
        <!--establish_contact = { who = <target> location = <target> }-->
      </complex>
      <complex entity="every_active_first_contact" scope="country">
        <annotation>Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_active_first_contact = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_ambient_object">
        <annotation>Iterate through every ambient object in the game - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_ambient_object = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_associate" scope="federation">
        <annotation>Iterate through each associate member of the federation - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_associate = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_attacker" scope="war">
        <annotation>Iterate through all attackers in the current war - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_attacker = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_bordering_country" scope="galactic_object">
        <annotation>Iterate through all bordering countries of a system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_bordering_country = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_combatant_fleet" scope="fleet">
        <annotation>Iterate through each fleet this fleet is in combat with - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_combatant_fleet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_controlled_planet" scope="country">
        <annotation>Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_controlled_planet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_council_member">
        <annotation>Iterate through each member of the galactic council - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_council_member = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_country">
        <annotation>Iterate through all countries - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_country = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_defender" scope="war">
        <annotation>Iterate through all defenders in the current war - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_defender = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_deposit" scope="planet">
        <annotation>Iterate through each deposit on the planet - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_deposit = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_enslaved_species" scope="country planet">
        <annotation>Check if any of the species with enslaved pops &lt;on the planet/in the country&gt; meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_enslaved_species = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_envoy" scope="country">
        <annotation>Iterate through each envoy available to the country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_envoy = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_espionage_asset" scope="espionage_operation no_scope spy_network">
        <annotation>Iterate through each espionage asset - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_espionage_asset = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_espionage_operation" scope="country no_scope spy_network">
        <annotation>Iterate through each espionage operation - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_espionage_operation = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_federation">
        <annotation>Iterate through each federation - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_federation = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_federation_ally" scope="country">
        <annotation>Iterate through all countries in a federation with the scoped country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_federation_ally = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_first_contact" scope="country">
        <annotation>Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_first_contact = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_fleet_in_orbit" scope="megastructure planet starbase">
        <annotation>Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_fleet_in_orbit = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_fleet_in_system" scope="galactic_object">
        <annotation>Iterate through each fleet in the current system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_fleet_in_system = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_galaxy_fleet">
        <annotation>Iterate through each fleet in the entire game - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_galaxy_fleet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_galaxy_planet">
        <annotation>Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_galaxy_planet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_galaxy_pop">
        <annotation>Executes enclosed effects for every pop in the game that meet the limit criteria</annotation>
        <!--every_galaxy_pop = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_galaxy_sector">
        <annotation>Iterate through all sectors in the game - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_galaxy_sector = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_galaxy_species">
        <annotation>Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_galaxy_species = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_galcom_member">
        <annotation>Iterate through each member of the galactic community - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_galcom_member = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_ground_combat_attacker" scope="planet">
        <annotation>Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_ground_combat_attacker = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_ground_combat_defender" scope="planet">
        <annotation>Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_ground_combat_defender = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_megastructure">
        <annotation>Iterate through each megastructure - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_megastructure = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_member" scope="federation">
        <annotation>Iterate through each member of the federation - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_member = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_moon" scope="planet">
        <annotation>Iterate through each moon of the planet - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_moon = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_neighbor_country" scope="country">
        <annotation>Iterate through all neighbor countries - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_neighbor_country = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_neighbor_system" scope="galactic_object">
        <annotation>Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_neighbor_system = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_neighbor_system_euclidean" scope="galactic_object">
        <annotation>Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_neighbor_system_euclidean = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_orbital_station" scope="country galactic_object">
        <annotation>Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_orbital_station = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_army" scope="country">
        <annotation>Iterate through each army that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_army = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_fleet" scope="country">
        <annotation>Iterate through each fleet owned by the country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_fleet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_leader" scope="country">
        <annotation>Iterate through each leader that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_leader = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_megastructure" scope="country">
        <annotation>Iterate through each owned megastructure - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_megastructure = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_planet" scope="country sector">
        <annotation>Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_planet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_pop" scope="country planet pop_faction sector">
        <annotation>Iterate through all owned pops - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_pop = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_pop_species" scope="country">
        <annotation>Iterate through each species of a country's owned pops - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_pop_species = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_sector" scope="country">
        <annotation>Iterate through every owned sector - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_sector = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_ship" scope="country fleet">
        <annotation>Iterate through each ship in the fleet or owned by the country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_ship = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_species" scope="country planet">
        <annotation>Check if any of the species &lt;on the planet/in the country&gt; meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_species = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_owned_starbase" scope="country">
        <annotation>Iterate through every owned starbase - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_owned_starbase = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_planet_army" scope="planet">
        <annotation>Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_planet_army = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_planet_within_border" scope="country">
        <annotation>Iterate through each planet within the current empire's borders - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_planet_within_border = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_playable_country">
        <annotation>Iterate through all playable countries - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_playable_country = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_pool_leader" scope="country">
        <annotation>Iterate through each leader that is recruitable for the country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_pool_leader = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_pop_faction" scope="country">
        <annotation>Iterate through all the country's pop factions - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_pop_faction = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_relation" scope="country">
        <annotation>Iterate through all relations - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_relation = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_rim_system">
        <annotation>Iterate through all rim systems - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_rim_system = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_rival_country" scope="country">
        <annotation>Iterate through all countries rivalled by the scoped country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_rival_country = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_ship_in_system" scope="galactic_object">
        <annotation>Iterate through each ship in the current system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_ship_in_system = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_situation" scope="country">
        <annotation>Iterate through each situation a country is experiencing - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_situation = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_species_pop" scope="species">
        <annotation>Iterate through each pop that belongs to this species; warning: resource-intensive! - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_species_pop = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_spynetwork" scope="country no_scope">
        <annotation>Iterate through each spynetwork - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_spynetwork = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_subject" scope="country">
        <annotation>Iterate through all subjects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_subject = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_system">
        <annotation>Iterate through all systems - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_system = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_system_ambient_object" scope="galactic_object">
        <annotation>Iterate through every ambient object in the solar system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_system_ambient_object = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_system_in_cluster">
        <annotation>Executes enclosed effects on every system in the cluster that meet the limit criteria</annotation>
        <!--every_system_in_cluster = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_system_megastructure">
        <annotation>Iterate through each megastructure in system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_system_megastructure = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_system_planet" scope="galactic_object">
        <annotation>Iterate through each planet in the current system - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_system_planet = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_system_within_border" scope="country sector">
        <annotation>Iterate through all systems within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_system_within_border = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_war" scope="country">
        <annotation>Iterate through all wars the country is engaged in - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_war = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="every_war_participant" scope="war">
        <annotation>Iterate through all war participants - executes the enclosed effects on all of them for which the limit triggers return true</annotation>
        <!--every_war_participant = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <simple entity="exile_leader_as" type="{key}" scope="army country fleet leader pop_faction">
        <annotation>Exiles the scoped country/fleet/army/pop faction's leader and saves them with a custom name</annotation>
      </simple>
      <simple entity="expire_site_event" type="{ancrel.7003}" scope="archaeological_site">
        <annotation>Manually flags an archaeological event as expired</annotation>
      </simple>
      <complex entity="export_modifier_to_variable" scope="army country fleet galactic_object leader megastructure planet pop pop_faction ship species">
        <annotation>Exports the value of a specified modifier in the current scope to a specified variable</annotation>
        <!--export_modifier_to_variable = { modifier = pop_growth_speed_reduction variable = <string> }-->
      </complex>
      <complex entity="export_resource_income_to_variable" scope="country">
        <annotation>Exports the value of the current country's monthly income of the specified resource to a variable</annotation>
        <!--export_resource_income_to_variable = { resource = energy variable = <string> }-->
      </complex>
      <complex entity="export_resource_stockpile_to_variable" scope="country">
        <annotation>Exports the value of the current country's stockpile of the specified resource to a variable</annotation>
        <!--export_resource_stockpile_to_variable = { resource = energy variable = <string> }-->
      </complex>
      <complex entity="export_trigger_value_to_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Exports the value of a trigger to a specified variable (so for num_pops, it'll export the number of pops)</annotation>
        <!--export_trigger_value_to_variable = {
	trigger = pop_produces_resource
	parameters = { resource = energy } (optional: specify extra parameters for triggers with { }
	variable = <string> (this example will print the amount of energy the pop produces to a variable)
	rounded = yes (default: no)
}-->
      </complex>
      
      
      
      
      <simple entity="finish_current_operation_stage" type="{yes/no yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed}" scope="espionage_operation">
        <annotation>Finish the current operation phase</annotation>
      </simple>
      <simple entity="finish_current_stage" type="{yes/no/country yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed country = use this country instead of excavator, no stage complete will be triggered.}" scope="archaeological_site">
        <annotation>Finish the current stage</annotation>
      </simple>
      <simple entity="finish_first_contact" type="{bool}" scope="first_contact">
        <annotation>Ends the First Contact</annotation>
      </simple>
      <simple entity="finish_site" type="{yes/no/country yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed country = use this country instead of excavator, no stage complete will be triggered.}" scope="archaeological_site">
        <annotation>Finish the whole archaeological site</annotation>
      </simple>
      <simple entity="finish_upgrade" type="{bool}" scope="megastructure">
        <annotation>Finish the current upgrade of a Mega Structure</annotation>
      </simple>
      <complex entity="fire_on_action">
        <annotation>Fires a made-up on_action</annotation>
        <!--fire_on_action = { on_action = <string> scopes = { from = X fromfrom = Y } }-->
      </complex>
      <complex entity="first_contact_event" scope="first_contact">
        <annotation>Fires a first contact event for the scoped first contact site, with optional DAYS and RANDOM delay</annotation>
        <!--first_contact_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="fleet_action_research_special_project" scope="fleet">
        <annotation>Sends a fleet to research a special project</annotation>
        <!--fleet_action_research_special_project = { special_project = test_project target = event_target:project_planet }-->
      </complex>
      <complex entity="fleet_event" scope="fleet">
        <annotation>Fires a fleet event for the scoped fleet, with optional DAYS and RANDOM delay</annotation>
        <!--fleet_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <simple entity="floor_variable" type="{string}" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Rounds a previously-set variable down to the previous integer</annotation>
      </simple>
      <simple entity="force_add_civic" type="{government-civic}" scope="country">
        <annotation>Adds civic to a government without checking the restrictions</annotation>
      </simple>
      <simple entity="force_faction_evaluation" type="{bool}" scope="pop">
        <annotation>Forces target pop to immediately evaluate their attraction to various pop factions</annotation>
      </simple>
      <simple entity="force_remove_civic" type="{civic/2}" scope="country">
        <annotation>Removes civic from a government without checking the restrictions</annotation>
      </simple>
      
      
      
      
      <complex entity="get_galaxy_setup_value">
        <annotation>Copies a value from the galaxy setup into a variable, optionally scaling it by an int value</annotation>
        <!--get_galaxy_setup_value = { which = <string> setting = <string> [ scale_by = <float> ] }
possible values: num_empires, num_advanced_empires, num_fallen_empires, num_marauder_empires, mid_game_year, end_game_year, victory_year, num_guaranteed_colonies, num_gateways, num_wormhole_pairs, num_hyperlanes, habitable_worlds_scale, primitive_worlds_scale, crisis_strength_scale, tech_costs_scale-->
      </complex>
      <complex entity="give_technology" scope="country">
        <annotation>Instantly gives a specific tech to the scoped country</annotation>
        <!--give_technology = { tech = tech_desert_colonization message = yes }-->
      </complex>
      <complex entity="guarantee_country" scope="country">
        <annotation>Makes a country guarantee another country</annotation>
        <!--guarantee_country = <target>
guarantee_country = { target = <target> }-->
      </complex>
      
      
      
      
      <list entity="hidden_effect" type="{effect}">
        <annotation>Prevents enclosed effects from being displayed in tooltip</annotation>
      </list>
      
      
      
      
      <complex entity="if">
        <annotation>Executes enclosed effects if limit criteria are met</annotation>
        <!--if = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <simple entity="increase_council_size" type="{bool}">
        <annotation>Increases the number of seats on the Galactic Council by 1</annotation>
      </simple>
      <complex entity="inverted_switch">
        <annotation>Executes the first appropriate effect set for a specific trigger treated as NOT</annotation>
        <!--inverted_switch = {
	trigger = <trigger>
	<corresponding key/bool/int> = { <effect> }
	<corresponding key/bool/int> > (less/greater than appear 'reversed') { <effect> }
	default = { <effect> }
}-->
      </complex>
      
      
      
      
      <complex entity="join_alliance" scope="country">
        <annotation>Join federation with target</annotation>
        <!--join_alliance = { who = <target> override_requirements = yes/no }-->
      </complex>
      <simple entity="join_war" type="{target}" scope="country">
        <annotation>Joins wars on the side of target country</annotation>
      </simple>
      <complex entity="join_war_on_side" scope="country">
        <annotation>Joins the war on the specified side</annotation>
        <!--join_war_on_side = { war = <target> side = attackers/defenders/<country> }-->
      </complex>
      
      
      
      
      <complex entity="kill_leader" scope="army country fleet leader planet ship">
        <annotation>Kills the scoped leader or leader of the scoped country/fleet/ship/planet/army</annotation>
        <!--kill_leader = { type = general type = scientist etc. }
kill_leader = {
	type = <key, optional, if left out will kill scoped leader> 
	show_notification = <yes/no> heir = <yes, optional, if added to type = ruler, will kill heir instead>
	fire = yes (default: no; if yes, fires on_leader_fired instead of on_leader_death
}-->
      </complex>
      <simple entity="kill_pop" type="{bool}" scope="pop">
        <annotation>Instantly destroys the scoped pop</annotation>
      </simple>
      
      
      
      
      <complex entity="leader_event" scope="leader">
        <annotation>Fires a leader event for the scoped leader</annotation>
        <!--leader_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="leave_alliance" scope="country">
        <annotation>Removes scoped country from any alliances it is in</annotation>
        <!--leave_alliance = {
	override_requirements = yes/no (default: no)
	apply_opinion_penalty = yes (default: no; sets whether 'Broke Federation' opinion is applied)
}-->
      </complex>
      <simple entity="link_wormholes" type="{from}" scope="galactic_object">
        <annotation>Link the wormhole from the scoped system to the wormhole in the target system</annotation>
      </simple>
      <complex entity="locked_random_list">
        <annotation>Picks one random set of effects from a list, influenced by relative weight once per event scope</annotation>
        <!--locked_random_list = { 50 = { <list sequence="only" type="{effect}" /> } 20 = { <list sequence="only" type="{effect}" /> } 30 = { <list sequence="only" type="{effect}" /> } 999 = { <list sequence="only" type="{effect}" /> } }-->
      </complex>
      <simple entity="log">
        <annotation>Prints a message to game.log for debugging purposes</annotation>
      </simple>
      <simple entity="log_error">
        <annotation>Prints a message to error.log for debugging purposes</annotation>
      </simple>
      
      
      
      
      <complex entity="modify_army" scope="army">
        <annotation>Modifies army with parameters</annotation>
        <!--modify_army = {
	name = <string>
	owner = <target>
	species = <target>/random
	type = <key>
}-->
      </complex>
      <complex entity="modify_species" scope="country leader planet pop species">
        <annotation>Creates a new, modified species based on an already-extant species</annotation>
        <!--modify_species = {
	species = <target> # species to modify
	base = <target>/auto/none # new base species; default: auto (uses species)
	add_trait = <key> # optional, can specify multiple
	remove_trait = <key> # optional, can specify multiple
	add_traits_at_start_of_list = yes # optional, pushes out other traits if needed
	ideal_planet_class = <target or pc_name> # optional
	change_scoped_species = yes/no # modify scoped pops/planet/leader/country; default: yes
	portrait = <target or portrait name> # optional
	effect = { SCOPE_SPECIES } # optional effect to run on the resulting new species, is executed after any handling of change_scoped_species
}-->
      </complex>
      <complex entity="modulo_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Modulos a previously-set variable by a specific amount i.e. X % Y</annotation>
        <!--modulo_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }-->
      </complex>
      <complex entity="multiply_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Multiplies a previously-set variable by a specific amount</annotation>
        <!--multiply_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }-->
      </complex>
      <simple entity="mutate_species" type="{bool}" scope="species">
        <annotation>Randomly mutate a species</annotation>
      </simple>
      
      
      
      
      <simple entity="observer_event">
        <annotation>Fires an observer event for all observers</annotation>
      </simple>
      <simple entity="order_forced_return" type="{bool}" scope="fleet">
        <annotation>Forces scoped fleet to retreat to friendly territory</annotation>
      </simple>
      <complex entity="ordered_active_first_contact" scope="country">
        <annotation>Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_active_first_contact = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_ambient_object">
        <annotation>Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_ambient_object = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_associate" scope="federation">
        <annotation>Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_associate = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_attacker" scope="war">
        <annotation>Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_attacker = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_bordering_country" scope="galactic_object">
        <annotation>Iterate through all bordering countries of a system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_bordering_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_combatant_fleet" scope="fleet">
        <annotation>Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_combatant_fleet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_controlled_planet" scope="country">
        <annotation>Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_controlled_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_council_member">
        <annotation>Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_council_member = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_country">
        <annotation>Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_defender" scope="war">
        <annotation>Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_defender = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_deposit" scope="planet">
        <annotation>Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_deposit = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_enslaved_species" scope="country planet">
        <annotation>Check if any of the species with enslaved pops &lt;on the planet/in the country&gt; meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_enslaved_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_envoy" scope="country">
        <annotation>Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_envoy = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_espionage_asset" scope="espionage_operation no_scope spy_network">
        <annotation>Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_espionage_asset = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_espionage_operation" scope="country no_scope spy_network">
        <annotation>Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_espionage_operation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_federation">
        <annotation>Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_federation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_federation_ally" scope="country">
        <annotation>Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_federation_ally = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_first_contact" scope="country">
        <annotation>Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_first_contact = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_fleet_in_orbit" scope="megastructure planet starbase">
        <annotation>Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_fleet_in_orbit = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_fleet_in_system" scope="galactic_object">
        <annotation>Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_fleet_in_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_galaxy_fleet">
        <annotation>Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_galaxy_fleet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_galaxy_planet">
        <annotation>Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_galaxy_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_galaxy_sector">
        <annotation>Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_galaxy_sector = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_galaxy_species">
        <annotation>Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_galaxy_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_galcom_member">
        <annotation>Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_galcom_member = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_ground_combat_attacker" scope="planet">
        <annotation>Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_ground_combat_attacker = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_ground_combat_defender" scope="planet">
        <annotation>Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_ground_combat_defender = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_megastructure">
        <annotation>Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_megastructure = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_member" scope="federation">
        <annotation>Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_member = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_moon" scope="planet">
        <annotation>Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_moon = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_neighbor_country" scope="country">
        <annotation>Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_neighbor_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_neighbor_system" scope="galactic_object">
        <annotation>Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_neighbor_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_neighbor_system_euclidean" scope="galactic_object">
        <annotation>Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_neighbor_system_euclidean = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_orbital_station" scope="country galactic_object">
        <annotation>Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_orbital_station = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_army" scope="country">
        <annotation>Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_army = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_fleet" scope="country">
        <annotation>Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_fleet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_leader" scope="country">
        <annotation>Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_leader = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_megastructure" scope="country">
        <annotation>Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_megastructure = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_planet" scope="country sector">
        <annotation>Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_pop" scope="country planet pop_faction sector">
        <annotation>Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_pop = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_pop_species" scope="country">
        <annotation>Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_pop_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_sector" scope="country">
        <annotation>Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_sector = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_ship" scope="country fleet">
        <annotation>Iterate through each ship in the fleet or owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_ship = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_species" scope="country planet">
        <annotation>Check if any of the species &lt;on the planet/in the country&gt; meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_owned_starbase" scope="country">
        <annotation>Iterate through every owned starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_owned_starbase = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_planet_army" scope="planet">
        <annotation>Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_planet_army = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_planet_within_border" scope="country">
        <annotation>Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_planet_within_border = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_playable_country">
        <annotation>Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_playable_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_pool_leader" scope="country">
        <annotation>Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_pool_leader = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_pop_faction" scope="country">
        <annotation>Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_pop_faction = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_relation" scope="country">
        <annotation>Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_relation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_rim_system">
        <annotation>Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_rim_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_rival_country" scope="country">
        <annotation>Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_rival_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_ship_in_system" scope="galactic_object">
        <annotation>Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_ship_in_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_situation" scope="country">
        <annotation>Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_situation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_species_pop" scope="species">
        <annotation>Iterate through each pop that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_species_pop = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_spynetwork" scope="country no_scope">
        <annotation>Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_spynetwork = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_subject" scope="country">
        <annotation>Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_subject = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_system">
        <annotation>Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_system_ambient_object" scope="galactic_object">
        <annotation>Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_system_ambient_object = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_system_megastructure">
        <annotation>Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_system_megastructure = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_system_planet" scope="galactic_object">
        <annotation>Iterate through each planet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_system_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_system_within_border" scope="country sector">
        <annotation>Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_system_within_border = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_war" scope="country">
        <annotation>Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_war = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="ordered_war_participant" scope="war">
        <annotation>Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)</annotation>
        <!--ordered_war_participant = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="owned_fleet_list_tooltip" scope="country">
        <annotation>Prints a list of the country's fleets that match the limit triggers in a tooltip, each separated by a line break</annotation>
        <!--owned_fleet_list_tooltip = { limit = { <complex sequence="only" type="{trigger}" /> } divider_tooltip = localisation }-->
      </complex>
      <complex entity="owned_leader_list_tooltip" scope="country">
        <annotation>Prints a list of the country's leaders that match the limit triggers in a tooltip, each separated by a line break</annotation>
        <!--owned_leader_list_tooltip = { limit = { <complex sequence="only" type="{trigger}" /> } }-->
      </complex>
      <complex entity="owned_planet_list_tooltip" scope="country">
        <annotation>Prints a list of the country's planets that match the limit triggers in a tooltip, each separated by a line break</annotation>
        <!--owned_planet_list_tooltip = { limit = { <complex sequence="only" type="{trigger}" /> } }-->
      </complex>
      <complex entity="owned_pop_faction_list_tooltip" scope="country">
        <annotation>Prints a list of the country's pop factions that match the limit triggers in a tooltip, each separated by a line break</annotation>
        <!--owned_pop_faction_list_tooltip = { limit = { <complex sequence="only" type="{trigger}" /> } }-->
      </complex>
      
      
      
      
      <simple entity="pass_resolution" type="{resolution type}" scope="country">
        <annotation>Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type</annotation>
      </simple>
      <simple entity="pass_resolution_no_cooldown" type="{resolution type}" scope="country">
        <annotation>Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type. Skips the cooldown on the relevant category</annotation>
      </simple>
      <complex entity="pass_targeted_resolution" scope="country">
        <annotation>Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type that has the specified target. Ignores whether the target is valid or not</annotation>
        <!--pass_targeted_resolution = { resolution = <resolution type> target = <target>-->
      </complex>
      <complex entity="planet_event" scope="planet">
        <annotation>Fires a planet event for the scoped planet, with optional DAYS and RANDOM delay</annotation>
        <!--planet_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <simple entity="play_sound" type="{myfirstsoundeffect}">
        <annotation>Play the defined sound effect</annotation>
      </simple>
      <simple entity="pop_change_ethic" type="{key}" scope="pop">
        <annotation>Changes scoped pop to chosen ethic</annotation>
      </simple>
      <complex entity="pop_event" scope="pop">
        <annotation>Fires a pop event for the scoped pop, with optional DAYS and RANDOM delay</annotation>
        <!--pop_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="pop_faction_event" scope="pop_faction">
        <annotation>Fires a pop faction event for the scoped pop faction, with optional DAYS and RANDOM delay</annotation>
        <!--pop_faction_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <simple entity="pop_force_add_ethic" type="{key}" scope="pop">
        <annotation>Adds a specific ethic to the scoped pop regardless if pop-species allows ethic divergence or not</annotation>
      </simple>
      <simple entity="pop_remove_ethic" type="{key}" scope="pop">
        <annotation>Removes a specific ethic from the scoped pop</annotation>
      </simple>
      <simple entity="prevent_anomaly" type="{bool}" scope="planet">
        <annotation>Disables or enables anomaly generation for the scoped planet</annotation>
      </simple>
      
      
      
      
      <complex entity="queue_actions" scope="fleet">
        <annotation>Adds actions to the scoped fleet's action queue</annotation>
        <!--queue_actions = { repeat = { <fleet actions> } }-->
      </complex>
      
      
      
      
      <complex entity="random">
        <annotation>All enclosed effects may or may not be executed depending on set chance</annotation>
        <!--random = { chance = 50 <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="random_active_first_contact" scope="country">
        <annotation>Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_active_first_contact = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_ambient_object">
        <annotation>Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_ambient_object = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_associate" scope="federation">
        <annotation>Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_associate = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_attacker" scope="war">
        <annotation>Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_attacker = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_bordering_country" scope="galactic_object">
        <annotation>Iterate through all bordering countries of a system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_bordering_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_combatant_fleet" scope="fleet">
        <annotation>Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_combatant_fleet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_controlled_planet" scope="country">
        <annotation>Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_controlled_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_council_member">
        <annotation>Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_council_member = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_country">
        <annotation>Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_defender" scope="war">
        <annotation>Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_defender = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_deposit" scope="planet">
        <annotation>Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_deposit = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_enslaved_species" scope="country planet">
        <annotation>Check if any of the species with enslaved pops &lt;on the planet/in the country&gt; meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_enslaved_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_envoy" scope="country">
        <annotation>Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_envoy = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_espionage_asset" scope="espionage_operation no_scope spy_network">
        <annotation>Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_espionage_asset = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_espionage_operation" scope="country no_scope spy_network">
        <annotation>Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_espionage_operation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_federation">
        <annotation>Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_federation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_federation_ally" scope="country">
        <annotation>Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_federation_ally = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_first_contact" scope="country">
        <annotation>Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_first_contact = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_fleet_in_orbit" scope="megastructure planet starbase">
        <annotation>Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_fleet_in_orbit = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_fleet_in_system" scope="galactic_object">
        <annotation>Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_fleet_in_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_galaxy_fleet">
        <annotation>Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_galaxy_fleet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_galaxy_planet">
        <annotation>Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_galaxy_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_galaxy_sector">
        <annotation>Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_galaxy_sector = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_galaxy_species">
        <annotation>Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_galaxy_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_galcom_member">
        <annotation>Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_galcom_member = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_ground_combat_attacker" scope="planet">
        <annotation>Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_ground_combat_attacker = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_ground_combat_defender" scope="planet">
        <annotation>Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_ground_combat_defender = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_list">
        <annotation>Picks one random set of effects from a list, influenced by relative weight</annotation>
        <!--random_list = { 50 = { <list sequence="only" type="{effect}" /> } 20 = { <list sequence="only" type="{effect}" /> } 30 = { <list sequence="only" type="{effect}" /> } 999 = { <list sequence="only" type="{effect}" /> } }-->
      </complex>
      <complex entity="random_megastructure">
        <annotation>Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_megastructure = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_member" scope="federation">
        <annotation>Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_member = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_moon" scope="planet">
        <annotation>Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_moon = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_neighbor_country" scope="country">
        <annotation>Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_neighbor_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_neighbor_system" scope="galactic_object">
        <annotation>Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_neighbor_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_neighbor_system_euclidean" scope="galactic_object">
        <annotation>Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_neighbor_system_euclidean = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_orbital_station" scope="country galactic_object">
        <annotation>Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_orbital_station = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_army" scope="country">
        <annotation>Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_army = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_fleet" scope="country">
        <annotation>Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_fleet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_leader" scope="country">
        <annotation>Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_leader = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_megastructure" scope="country">
        <annotation>Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_megastructure = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_planet" scope="country sector">
        <annotation>Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_pop" scope="country planet pop_faction sector">
        <annotation>Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_pop = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_pop_species" scope="country">
        <annotation>Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_pop_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_sector" scope="country">
        <annotation>Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_sector = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_ship" scope="country fleet">
        <annotation>Iterate through each ship in the fleet or owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_ship = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_species" scope="country planet">
        <annotation>Check if any of the species &lt;on the planet/in the country&gt; meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_species = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_owned_starbase" scope="country">
        <annotation>Iterate through every owned starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_owned_starbase = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_planet_army" scope="planet">
        <annotation>Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_planet_army = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_planet_within_border" scope="country">
        <annotation>Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_planet_within_border = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_playable_country">
        <annotation>Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_playable_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_pool_leader" scope="country">
        <annotation>Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_pool_leader = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_pop" scope="planet">
        <annotation>Executes enclosed effects on a random pop that meets the limit criteria. Warning: deprecated, use random_owned_pop</annotation>
        <!--random_pop = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }-->
      </complex>
      <complex entity="random_pop_faction" scope="country">
        <annotation>Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_pop_faction = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_relation" scope="country">
        <annotation>Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_relation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_rim_system">
        <annotation>Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_rim_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_rival_country" scope="country">
        <annotation>Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_rival_country = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_ship_in_system" scope="galactic_object">
        <annotation>Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_ship_in_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_situation" scope="country">
        <annotation>Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_situation = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_species_pop" scope="species">
        <annotation>Iterate through each pop that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_species_pop = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_spynetwork" scope="country no_scope">
        <annotation>Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_spynetwork = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_subject" scope="country">
        <annotation>Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_subject = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_system">
        <annotation>Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_system = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_system_ambient_object" scope="galactic_object">
        <annotation>Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_system_ambient_object = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_system_megastructure">
        <annotation>Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_system_megastructure = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_system_planet" scope="galactic_object">
        <annotation>Iterate through each planet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_system_planet = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_system_within_border" scope="country sector">
        <annotation>Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_system_within_border = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_war" scope="country">
        <annotation>Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_war = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <complex entity="random_war_participant" scope="war">
        <annotation>Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly</annotation>
        <!--random_war_participant = {
	limit = { <complex sequence="only" type="{trigger}" /> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <complex sequence="only" type="{trigger}" /> }
	}
	<list sequence="only" type="{effect}" />
}-->
      </complex>
      <simple entity="randomize_flag_symbol" type="{pirate}" scope="country">
        <annotation>Randomizes a country's flag symbol within the selected category</annotation>
      </simple>
      <simple entity="recruitable" type="{bool}" scope="leader">
        <annotation>Sets scoped leader as non/recruitable</annotation>
      </simple>
      <simple entity="reduce_hp" type="{int}" scope="ship">
        <annotation>Reduces the hull points of the scoped ship by a specific amount</annotation>
      </simple>
      <simple entity="reduce_hp_percent" type="{float}" scope="ship">
        <annotation>Reduces the hull points of the scoped ship by a relative amount</annotation>
      </simple>
      <simple entity="remove_all_armies" type="{bool}" scope="planet">
        <annotation>Removes all armies on scoped planet</annotation>
      </simple>
      <simple entity="remove_all_buildings" type="{bool}" scope="planet">
        <annotation>Removes all buildings from the scoped planet</annotation>
      </simple>
      <simple entity="remove_all_districts" type="{bool}" scope="planet">
        <annotation>Removes all districts from the scoped planet</annotation>
      </simple>
      <simple entity="remove_ambient_object_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="ambient_object">
        <annotation>Removes a flag from the scoped ambient object</annotation>
      </simple>
      <simple entity="remove_archaeology_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="archaeological_site">
        <annotation>Removes a flag from the scoped arc site</annotation>
      </simple>
      <simple entity="remove_army" type="{bool}" scope="army">
        <annotation>Removes the scoped army</annotation>
      </simple>
      <simple entity="remove_army_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="army">
        <annotation>Removes a flag from the scoped army</annotation>
      </simple>
      <complex entity="remove_associate_member" scope="federation">
        <annotation>Removes a specific associate member from the federation</annotation>
        <!--remove_associate_member = { who = <country> override_requirements = yes/no }-->
      </complex>
      <simple entity="remove_auto_move_target" type="{bool}" scope="fleet ship">
        <annotation>Makes a fleet or ship stop auto-moving</annotation>
      </simple>
      <simple entity="remove_building" type="{key}" scope="planet">
        <annotation>Removes a specific building from the scoped planet</annotation>
      </simple>
      <complex entity="remove_claims" scope="galactic_object">
        <annotation>Removes claims on target system</annotation>
        <!--remove_claims = { who = <country> num_of_claims = x }-->
      </complex>
      <simple entity="remove_country_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="country">
        <annotation>Removes a flag from the scoped country</annotation>
      </simple>
      <simple entity="remove_deposit" type="{key/yes}" scope="deposit planet">
        <annotation>Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker</annotation>
      </simple>
      <simple entity="remove_deposit_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="deposit">
        <annotation>Removes a flag from the scoped deposit</annotation>
      </simple>
      <simple entity="remove_district" type="{key}" scope="planet">
        <annotation>Removes a specific district from the scoped planet</annotation>
      </simple>
      <simple entity="remove_espionage_asset_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="espionage_asset">
        <annotation>Removes a flag from the scoped espionage asset</annotation>
      </simple>
      <simple entity="remove_espionage_operation_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="espionage_operation">
        <annotation>Removes a flag from the scoped espionage operation</annotation>
      </simple>
      <complex entity="remove_favors" scope="country">
        <annotation>Remove &lt;value/all&gt; favors that scoped country have on target country</annotation>
        <!--remove_favors = {
target = <target>
value = <value/all/variable> }-->
      </complex>
      <simple entity="remove_federation_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="federation">
        <annotation>Removes a flag from the scoped federation</annotation>
      </simple>
      <simple entity="remove_first_contact_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="first_contact">
        <annotation>Removes a flag from the scoped first contact site</annotation>
      </simple>
      <simple entity="remove_fleet_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="fleet">
        <annotation>Removes a flag from the scoped fleet</annotation>
      </simple>
      <simple entity="remove_from_galactic_community" type="{bool}" scope="country">
        <annotation>Tries to remove the scoped country from the Galactic Community</annotation>
      </simple>
      <simple entity="remove_from_galactic_council" type="{bool}" scope="country">
        <annotation>Tries to remove the scoped country from the Galactic Council</annotation>
      </simple>
      <simple entity="remove_global_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}">
        <annotation>Removes a global flag</annotation>
      </simple>
      <complex entity="remove_hyperlane">
        <annotation>Removes existing hyperlane between two systems</annotation>
        <!--remove_hyperlane = { from = <system> to = <system> }-->
      </complex>
      <simple entity="remove_last_built_building" type="{bool}" scope="planet">
        <annotation>Removes last built building from the scoped planet</annotation>
      </simple>
      <simple entity="remove_last_built_district" type="{bool}" scope="planet">
        <annotation>Removes last built district from the scoped planet</annotation>
      </simple>
      <simple entity="remove_leader_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="leader">
        <annotation>Removes a flag from the scoped leader</annotation>
      </simple>
      <simple entity="remove_megastructure" type="{target mega reference}">
        <annotation>Removes a mega reference</annotation>
      </simple>
      <simple entity="remove_megastructure_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="megastructure">
        <annotation>Removes a flag from the scoped mega reference</annotation>
      </simple>
      <simple entity="remove_modifier" type="{key}" scope="country espionage_operation federation fleet galactic_object megastructure planet pop pop_faction ship spy_network">
        <annotation>Removes a specific modifier from the scope object</annotation>
      </simple>
      <simple entity="remove_notification_modifier" type="{key}" scope="country">
        <annotation>Remove a notification modifier to the country</annotation>
      </simple>
      <complex entity="remove_opinion_modifier" scope="country">
        <annotation>Removes a specific opinion modifier towards target country or any contry from the scoped country</annotation>
        <!--remove_opinion_modifier = { modifier = <key> who = <target (optional)> }-->
      </complex>
      <simple entity="remove_permanent_councillor" type="{bool}" scope="country">
        <annotation>Remove the provided country from their permanent council position</annotation>
      </simple>
      <simple entity="remove_planet" type="{bool}" scope="planet">
        <annotation>Removes the planet from the scope</annotation>
      </simple>
      <simple entity="remove_planet_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="planet">
        <annotation>Removes a flag from the scoped planet</annotation>
      </simple>
      <simple entity="remove_point_of_interest" type="{key}" scope="country">
        <annotation>Removes a specific point of interest from the scoped country's situation log</annotation>
      </simple>
      <simple entity="remove_pop_faction_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="pop pop_faction">
        <annotation>Removes a flag from the scoped pop's faction/pop faction</annotation>
      </simple>
      <simple entity="remove_pop_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="pop">
        <annotation>Removes a flag from the scoped pop</annotation>
      </simple>
      <complex entity="remove_random_starbase_building" scope="starbase">
        <annotation>Remove a number of random building(s) matching/not matching a type from the starbase</annotation>
        <!--remove_random_starbase_building = {
	type = <starbase building> ( optional. default: all )
	count = <int> (optional. default: 1 )
}-->
      </complex>
      <complex entity="remove_random_starbase_module" scope="starbase">
        <annotation>Remove a number of random module(s) matching/not matching a type from the starbase</annotation>
        <!--remove_random_starbase_module = {
	type = <starbase module> ( optional. default: all )
	count = <int> (optional. default: 1 )
}-->
      </complex>
      <complex entity="remove_relation_flag" scope="country">
        <annotation>Removes a specific relation flag towards target country from the scoped country</annotation>
        <!--remove_relation_flag = {
	who = <target>
	flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
}-->
      </complex>
      <simple entity="remove_relic" scope="country">
        <annotation>Removes the specified relic from the scoped country. remove_relic = &lt;relic_key&gt;</annotation>
      </simple>
      <simple entity="remove_ruler_trait" type="{trait}" scope="leader">
        <annotation>Removes a specific ruler trait from the scoped leader, even if they are not currently ruler; this is relevant if they ever become ruler</annotation>
      </simple>
      <simple entity="remove_saved_leader" type="{string}" scope="country">
        <annotation>Removes a saved leader for the scoped country with a lookup key</annotation>
      </simple>
      <simple entity="remove_sector_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="sector">
        <annotation>Removes a flag from the scoped sector</annotation>
      </simple>
      <simple entity="remove_ship_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="ship">
        <annotation>Removes a flag from the scoped ship</annotation>
      </simple>
      <simple entity="remove_situation_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="situation">
        <annotation>Removes a flag from the scoped situation</annotation>
      </simple>
      <simple entity="remove_species_flag" type="{key (note: one can use key@scope e.g. my_flag@from to track relationships between objects)}" scope="species">
        <annotation>Removes a flag from the scoped species</annotation>
      </simple>
      <simple entity="remove_spynetwork_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="spy_network">
        <annotation>Removes a flag from the scoped spy network</annotation>
      </simple>
      <simple entity="remove_stage_modifier" type="{key}" scope="espionage_operation">
        <annotation>Removes a specific modifier from the espionage operation current stage</annotation>
      </simple>
      <simple entity="remove_star_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="galactic_object">
        <annotation>Removes a flag from the scoped system</annotation>
      </simple>
      <complex entity="remove_starbase_building" scope="starbase">
        <annotation>Remove a building from a certain slot or all slots on a starbase</annotation>
        <!--remove_starbase_building = { slot = <int> (optional, default = all) building = <starbase_building> (optional) }-->
      </complex>
      <simple entity="remove_starbase_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="starbase">
        <annotation>Removes a flag from the scoped starbase</annotation>
      </simple>
      <complex entity="remove_starbase_module" scope="starbase">
        <annotation>Removes a module from a certain slot or all slots on a starbase</annotation>
        <!--remove_starbase_module = { slot = <int> (optional, default = all) module = <starbase_module> (optional) }-->
      </complex>
      <simple entity="remove_trait" type="{key}" scope="leader">
        <annotation>Removes a specific trait from the scoped leader</annotation>
      </simple>
      <simple entity="remove_war_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="war">
        <annotation>Removes a flag from the scoped war</annotation>
      </simple>
      <simple entity="remove_war_participant" type="{target}" scope="war">
        <annotation>Removes a specified country from the war</annotation>
      </simple>
      <simple entity="rename_species" type="{of the following: name = an entry within the species name database name = random name_list = key }}" scope="species">
        <annotation>rename_species = {</annotation>
      </simple>
      <simple entity="repair_percentage" type="{bool}" scope="fleet ship">
        <annotation>Restores a certain percentage of hull points to the scoped ship</annotation>
      </simple>
      <simple entity="repair_ship" type="{bool}" scope="ship">
        <annotation>Restores all hull points to the scoped ship</annotation>
      </simple>
      <simple entity="reroll_deposits" type="{bool}" scope="planet">
        <annotation>Rebuild resource deposits on target planet</annotation>
      </simple>
      <simple entity="reroll_planet_modifiers" type="{bool}" scope="planet">
        <annotation>Rebuild modifiers on target planet</annotation>
      </simple>
      <simple entity="reroll_random" type="{bool}">
        <annotation>Rerolls the random seed. Use if you want to have a second random_list return a different result. Do not use in tooltips that show random results, because the tooltip will be wrong!</annotation>
      </simple>
      <simple entity="reset_current_stage" type="{yes/no yes = also randomize new difficulty if stage allows that. no = does not change difficulty}" scope="archaeological_site">
        <annotation>Resets the current stage</annotation>
      </simple>
      <simple entity="reset_years_of_peace" type="{bool}" scope="country">
        <annotation>Resets years of peace for a country</annotation>
      </simple>
      <complex entity="resettle_pop">
        <annotation>Instantly resettles pop</annotation>
        <!--resettle_pop = { pop = <target pop> planet = <target planet> tile = <target tile> }-->
      </complex>
      <simple entity="restore_galactic_community_leader_backup_data" type="{bool}">
        <annotation>Retores backed up data to the Galactic Custodian/Emperor</annotation>
      </simple>
      <simple entity="room_name_override" type="{room_name}" scope="country">
        <annotation>Sets the room background of the empire. Provide an empty string to remove the override</annotation>
      </simple>
      <simple entity="round_variable" type="{string}" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Rounds a previously-set variable to the closest integer</annotation>
      </simple>
      <complex entity="round_variable_to_closest" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Rounds a previously-set variable to the closest X</annotation>
        <!--round_variable_to_closest = {
	which = <string>
	value = <float>/<variable>/<scope.variable>/trigger:<trigger> (variable will be rounded to a multiple of this value)
}-->
      </complex>
      <simple entity="run_ai_strategic_data" scope="country">
        <annotation>Recomputes ALL strategic data for AI = yes</annotation>
      </simple>
      <simple entity="run_ai_strategic_war_data" scope="country">
        <annotation>Recomputes strategic war ( attack / defense ) data for AI = yes</annotation>
      </simple>
      
      
      
      
      <simple entity="save_event_target_as" type="{string}">
        <annotation>Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain</annotation>
      </simple>
      <simple entity="save_global_event_target_as" type="{string}">
        <annotation>Saves the current scope as an arbitrarily-named target to be referenced later, accessible globally until cleared</annotation>
      </simple>
      <simple entity="set_adjective" type="{string}" scope="country">
        <annotation>Sets the adjective of the scoped country</annotation>
      </simple>
      <simple entity="set_advisor_active" type="{bool}" scope="country">
        <annotation>Enables or disables the VIR window pop-in</annotation>
      </simple>
      <simple entity="set_age" type="{int}" scope="leader">
        <annotation>Sets the age of the scoped leader</annotation>
      </simple>
      <simple entity="set_aggro_range" type="{int}" scope="country fleet">
        <annotation>Sets the scoped fleet/country's aggro range in intra-system units</annotation>
      </simple>
      <simple entity="set_aggro_range_measure_from" type="{key, self/return_point}" scope="country fleet">
        <annotation>Determines whether the scoped fleet/country's aggro range is measured from the fleet's current position or its spawn location</annotation>
      </simple>
      <simple entity="set_ai_personality" type="{personality}" scope="country">
        <annotation>Sets the AI personality of a country to a new one</annotation>
      </simple>
      <simple entity="set_allow_subjects_to_join" type="{use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead. set_allow_subjects_to_join = yes/no}" scope="federation">
        <annotation>Sets right for subjects to join federations</annotation>
      </simple>
      <simple entity="set_ambient_object_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="ambient_object">
        <annotation>Sets an arbitrarily-named flag on the scoped ambient object</annotation>
      </simple>
      <simple entity="set_archaeology_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="archaeological_site">
        <annotation>Sets an arbitrarily-named flag on the scoped arc site</annotation>
      </simple>
      <simple entity="set_army_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="army">
        <annotation>Sets an arbitrarily-named flag on the scoped army</annotation>
      </simple>
      <complex entity="set_asteroid_belt" scope="galactic_object">
        <annotation>Sets an asteroid belt at the distance in the scope</annotation>
        <!--Example:
set_asteroid_belt = {
	radius=<desired radius>
	type=<asteroid belt type key>
}-->
      </complex>
      <simple entity="set_built_species" type="{target}" scope="country">
        <annotation>Changes the built species of the scoped object</annotation>
      </simple>
      <simple entity="set_capital" type="{bool}" scope="planet">
        <annotation>Sets the scoped planet to be the capital of its owner country</annotation>
      </simple>
      <complex entity="set_citizenship_type" scope="leader pop species">
        <annotation>Set citizenship type for scoped species/pop/leader</annotation>
        <!--set_citizenship_type = { country = <target> type = citizenship_full cooldown = yes }-->
      </complex>
      <simple entity="set_city_graphical_culture" type="{key}" scope="country">
        <annotation>Sets the scoped country's city graphical culture</annotation>
      </simple>
      <complex entity="set_closed_borders" scope="country">
        <annotation>Changes closed borders status between two countries</annotation>
        <!--set_closed_borders = {
	who = target
	status = yes/no
	forced = <int>/<variable> (number of years)
}-->
      </complex>
      <complex entity="set_colonization_controls" scope="leader pop species">
        <annotation>Set colonization control for scoped species/pop/leader</annotation>
        <!--set_colonization_controls = { country = <target> type = yes/no cooldown = yes }-->
      </complex>
      <simple entity="set_colony_type" type="{colony type}" scope="planet">
        <annotation>Sets the colony's designation type</annotation>
      </simple>
      <simple entity="set_controller" type="{target}" scope="fleet planet">
        <annotation>Instantly sets the planet/fleet's controller to target country</annotation>
      </simple>
      <simple entity="set_cooldown" type="{int}" scope="leader">
        <annotation>Locks the leader in its current role for the next X days</annotation>
      </simple>
      <simple entity="set_council_emergency_measures" type="{bool}">
        <annotation>Sets whether council members can propose emergency measures or not</annotation>
      </simple>
      <simple entity="set_council_size" type="{int}">
        <annotation>Sets the number of seats on the Galactic Council</annotation>
      </simple>
      <simple entity="set_council_veto" type="{bool}">
        <annotation>Sets whether council members can veto resolutions or not</annotation>
      </simple>
      <simple entity="set_country_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="country">
        <annotation>Sets an arbitrarily-named flag on the scoped country</annotation>
      </simple>
      <simple entity="set_country_type" type="{key}" scope="country">
        <annotation>Changes the country type of the scoped country</annotation>
      </simple>
      <simple entity="set_crisis_sound" type="{myfirstsoundeffect}">
        <annotation>Sets the crisis ambient loop to the current effect</annotation>
      </simple>
      <simple entity="set_custodian_term_days" type="{days}">
        <annotation>Set the current Custodian term time. -1 will make the Custodianship permanent</annotation>
      </simple>
      <simple entity="set_custom_capital_location" type="{target}" scope="country">
        <annotation>Sets a custom spatial object as custom country capital location</annotation>
      </simple>
      <simple entity="set_deposit" type="{key/random}" scope="planet">
        <annotation>Replaces resource deposit on the scoped planet</annotation>
      </simple>
      <simple entity="set_deposit_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="deposit">
        <annotation>Sets an arbitrarily-named flag on the scoped deposit</annotation>
      </simple>
      <complex entity="set_diplomacy_action_setting" scope="federation">
        <annotation>Sets diplomatic action custom setting</annotation>
        <!--Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_diplomacy_action_setting = {
	action = <action_key>
	settings = {
	tvote_type = default
	}
}-->
      </complex>
      <simple entity="set_disable_at_health" type="{0-1 float}" scope="ship">
        <annotation>Sets the scoped ship to become disabled at a certain hull point percentage</annotation>
      </simple>
      <simple entity="set_disabled" type="{bool}" scope="ship">
        <annotation>Enables or disables the scoped ship</annotation>
      </simple>
      <simple entity="set_emperor_can_change_council_members" type="{bool}">
        <annotation>Sets whether the Galactic Emperor can change Imperial Council members or not</annotation>
      </simple>
      <simple entity="set_empire_flag" type="{flag}" scope="country">
        <annotation>Sets the flag of the current Empire</annotation>
      </simple>
      <simple entity="set_empire_name" type="{name}" scope="country">
        <annotation>Sets the name of the current Empire</annotation>
      </simple>
      <simple entity="set_equal_voting_power" type="{use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead. set_equal_voting_power = yes/no}" scope="federation">
        <annotation>Sets different voting weight</annotation>
      </simple>
      <simple entity="set_espionage_asset_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="espionage_asset">
        <annotation>Sets an arbitrarily-named flag on the scoped espionage asset</annotation>
      </simple>
      <simple entity="set_espionage_operation_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="espionage_operation">
        <annotation>Sets an arbitrarily-named flag on the scoped espionage operation</annotation>
      </simple>
      <simple entity="set_espionage_operation_progress_locked" type="{bool}" scope="espionage_operation">
        <annotation>Locks or unlocks the progress of an espionage operation</annotation>
      </simple>
      <simple entity="set_event_locked" type="{bool}" scope="fleet">
        <annotation>Silently disables the scoped fleet to prevent player action, remember to unlock at the end of the event</annotation>
      </simple>
      <complex entity="set_faction_hostility" scope="country">
        <annotation>Sets the aggro state of the scoped faction-type country</annotation>
        <!--set_faction_hostility = { target = country set_hostile = yes set_neutral = no set_friendly = no }-->
      </complex>
      <simple entity="set_federation_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="federation">
        <annotation>Sets an arbitrarily-named flag on the scoped federation</annotation>
      </simple>
      <simple entity="set_federation_law" type="{federation law}" scope="federation">
        <annotation>Sets the given law for the scoped federation</annotation>
      </simple>
      <simple entity="set_federation_leader" type="{target}" scope="country federation">
        <annotation>Sets a country to lead a federation</annotation>
      </simple>
      <complex entity="set_federation_settings" scope="federation">
        <annotation>Sets diplomatic action custom setting</annotation>
        <!--Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_settings = {
	<setting> = <value>
	...
}-->
      </complex>
      <simple entity="set_federation_succession_term" type="{use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead. set_federation_succession_type = federation succession term Federation succession terms: status_change/years_10/years_20/years_30/years_40}" scope="federation">
        <annotation>Sets federation succession term to the scoped federation</annotation>
      </simple>
      <simple entity="set_federation_succession_type" type="{use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead. set_federation_succession_type = federation succession type Federation succession types: strongest/diplomatic_weight/rotation/challenge/random}" scope="federation">
        <annotation>Sets federation succession type to the scoped federation</annotation>
      </simple>
      <simple entity="set_federation_type" type="{federation type}" scope="federation">
        <annotation>Sets federation type to the scoped federation</annotation>
      </simple>
      <simple entity="set_female_heir_title" type="{Little Executioneress}" scope="country">
        <annotation>Sets the country's female heir title to a custom value</annotation>
      </simple>
      <simple entity="set_female_ruler_title" type="{Grand Executionerress}" scope="country">
        <annotation>Sets the country's female ruler title to a custom value</annotation>
      </simple>
      <simple entity="set_first_contact_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="first_contact">
        <annotation>Sets an arbitrarily-named flag on the scoped first contact site</annotation>
      </simple>
      <simple entity="set_first_contact_stage" type="{stage name}" scope="first_contact">
        <annotation>Sets the given stage for the scoped first contact</annotation>
      </simple>
      <simple entity="set_fleet_bombardment_stance" type="{selective}" scope="fleet">
        <annotation>Sets the bombardment stance of the scoped fleet</annotation>
      </simple>
      <simple entity="set_fleet_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="fleet">
        <annotation>Sets an arbitrarily-named flag on the scoped fleet</annotation>
      </simple>
      <complex entity="set_fleet_formation" scope="fleet">
        <annotation>Sets a custom fleet formation on a fleet</annotation>
        <!--set_fleet_formation = { position = { x = 1 y = 1 } position = { x = 2 y = 1 } }-->
      </complex>
      <simple entity="set_fleet_stance" type="{key, aggressive/passive/evasive}" scope="fleet">
        <annotation>Sets the stance of the scoped fleet</annotation>
      </simple>
      <simple entity="set_formation_scale" type="{float}" scope="fleet">
        <annotation>Scales the scoped fleet's formation's ship spacing, above and below 1.0</annotation>
      </simple>
      <simple entity="set_free_migration" type="{use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead. set_free_migration = yes/no}" scope="federation">
        <annotation>Sets unified migration flag for federation</annotation>
      </simple>
      <simple entity="set_galactic_custodian" type="{bool}" scope="country">
        <annotation>Sets whether or not the scoped country is the Galactic Custodian</annotation>
      </simple>
      <simple entity="set_galactic_defense_force" type="{bool}">
        <annotation>Sets whether the Galactic Defense force or Imperial Armada exists</annotation>
      </simple>
      <simple entity="set_galactic_emperor" type="{bool}" scope="country">
        <annotation>Sets whether or not the scoped country is the Galactic Emperor</annotation>
      </simple>
      <simple entity="set_global_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}">
        <annotation>Sets an arbitrarily-named global flag</annotation>
      </simple>
      <simple entity="set_government_cooldown" type="{500/default/no}" scope="country">
        <annotation>Locks the country's government for a given period of days, the default cooldown, or unlocks it</annotation>
      </simple>
      <simple entity="set_graphical_culture" type="{key}" scope="country megastructure">
        <annotation>Sets the scoped object's graphical culture</annotation>
      </simple>
      <simple entity="set_halted" type="{nDays}" scope="megastructure">
        <annotation>Sets the mega reference upgrade to halted status for n days. -1 days = indefinitely</annotation>
      </simple>
      <simple entity="set_heir" type="{target}" scope="country">
        <annotation>Sets the target leader to be the scoped country's heir</annotation>
      </simple>
      <simple entity="set_home_base" type="{event_target:cool_starbase}" scope="fleet">
        <annotation>Set the home base of the scoped fleet to the specified starbase</annotation>
      </simple>
      <simple entity="set_hostile" type="{from}" scope="country">
        <annotation>Sets the target country as hostile. This will work on countries you don't have comms with, unlike set_faction_hostility</annotation>
      </simple>
      <simple entity="set_is_female" type="{true}" scope="leader">
        <annotation>Sets the gender of the scoped leader</annotation>
      </simple>
      <simple entity="set_leader" type="{key}" scope="army country fleet pop_faction">
        <annotation>Reinstates a previously-exiled leader to the scoped country/fleet/army/pop faction</annotation>
      </simple>
      <simple entity="set_leader_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="leader">
        <annotation>Sets an arbitrarily-named flag on the scoped leader</annotation>
      </simple>
      <complex entity="set_living_standard" scope="leader pop species">
        <annotation>Set living standard for scoped species/pop/leader</annotation>
        <!--set_living_standard = { country = <target> type = living_standard_good cooldown = yes }-->
      </complex>
      <complex entity="set_location" scope="ambient_object fleet">
        <annotation>Sets the fleet/ambient object's location, can be fine-tuned</annotation>
        <!--set_location = <target>
set_location = {
	target = <target>
	distance = <int/random>
	angle = <int/random>
	direction = <in_system/out_system>
}-->
      </complex>
      <simple entity="set_male_heir_title" type="{Little Executioner}" scope="country">
        <annotation>Sets the country's male heir title to a custom value</annotation>
      </simple>
      <simple entity="set_male_ruler_title" type="{Grand Executioner}" scope="country">
        <annotation>Sets the country's male ruler title to a custom value</annotation>
      </simple>
      <simple entity="set_market_leader" scope="country">
        <annotation>Set scoped country as the current Galactic Market leader. set_market_leader = &lt;yes/no&gt;</annotation>
      </simple>
      <simple entity="set_megastructure_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="megastructure">
        <annotation>Sets an arbitrarily-named flag on the scoped mega reference</annotation>
      </simple>
      <simple entity="set_mia" type="{bool}" scope="fleet">
        <annotation>Sets the current fleet to go missing in action and return home</annotation>
      </simple>
      <complex entity="set_migration_controls" scope="leader pop species">
        <annotation>Set migration control for scoped species/pop/leader</annotation>
        <!--set_migration_controls = { country = <target> type = yes/no cooldown = yes }-->
      </complex>
      <complex entity="set_military_service_type" scope="leader pop species">
        <annotation>Set military service type for scoped species/pop/leader</annotation>
        <!--set_military_service_type = { country = <target> type = military_service_full cooldown = yes }-->
      </complex>
      <simple entity="set_mission" type="{passive_observation}" scope="fleet">
        <annotation>Sets the current mission of an observation station</annotation>
      </simple>
      <simple entity="set_name" type="{string}" scope="army country federation first_contact fleet galactic_object leader megastructure planet pop_faction sector ship war">
        <annotation>Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction</annotation>
      </simple>
      <simple entity="set_only_leader_builds_fleets" type="{use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead. set_only_leader_builds_fleets = yes/no}" scope="federation">
        <annotation>Sets exclusive right to build fleets by federation leader</annotation>
      </simple>
      <simple entity="set_origin" type="{origin}" scope="country">
        <annotation>Sets the country's origin to a certain value. Note: This will not run effects executed during galaxy generation</annotation>
      </simple>
      <simple entity="set_owner" type="{target}" scope="army fleet leader megastructure planet starbase">
        <annotation>Instantly sets the owner of the scoped planet/fleet/army/starbase to target country</annotation>
      </simple>
      <complex entity="set_planet_entity" scope="planet">
        <annotation>Change entity of a planet</annotation>
        <!--Example:
set_planet_entity = {
	entity = <name of entity>
	graphical_culture = <target or name of culture>
	picture = <picture override>
	atmosphere_color = <color from 3 components>
	atmosphere_intensity = <0.0 - 1.0>
	atmosphere_width = <0.0 - 1.0> 
}-->
      </complex>
      <simple entity="set_planet_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="planet">
        <annotation>Sets an arbitrarily-named flag on the scoped planet</annotation>
      </simple>
      <simple entity="set_planet_name" type="{name}" scope="planet">
        <annotation>Sets the name of the current planet</annotation>
      </simple>
      <simple entity="set_planet_size" type="{int}" scope="planet">
        <annotation>Sets the planet size to a specified number</annotation>
      </simple>
      <simple entity="set_planetary_ascension_tier" type="{int}" scope="planet">
        <annotation>Sets the planet's ascension tier to the specified value</annotation>
      </simple>
      <complex entity="set_player" scope="country">
        <annotation>Assign the player of the target country to play the scoped country instead</annotation>
        <!--event_target:new_country = { set_player = event_target:old_country }-->
      </complex>
      <complex entity="set_policy">
        <annotation>Sets a policy to a specific option for the scoped country and specifies if policy cooldown should go into effect</annotation>
        <!--set_policy = { policy = <key> option = <key> cooldown = <bool> }-->
      </complex>
      <simple entity="set_policy_cooldown" type="{policy group e.g. diplomatic_stance}" scope="country planet pop ship">
        <annotation>Sets the specified policy group to have a cooldown as if the policy had just been changed</annotation>
      </simple>
      <simple entity="set_pop_faction" type="{target}" scope="pop">
        <annotation>Sets the scoped pop to belong to a specific pop faction</annotation>
      </simple>
      <simple entity="set_pop_faction_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="pop pop_faction">
        <annotation>Sets an arbitrarily-named flag on the scoped pop's faction/pop faction</annotation>
      </simple>
      <simple entity="set_pop_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="pop">
        <annotation>Sets an arbitrarily-named flag on the scoped pop</annotation>
      </simple>
      <complex entity="set_population_controls" scope="leader pop species">
        <annotation>Set population control for scoped species/pop/leader</annotation>
        <!--set_population_controls = { country = <target> type = yes/no cooldown = yes }-->
      </complex>
      <simple entity="set_primitive_age" type="{renaissance_age}" scope="country">
        <annotation>Sets a 'primitive age' for the scoped (primitive, pre-FTL) country</annotation>
      </simple>
      <complex entity="set_purge_type" scope="leader pop species">
        <annotation>Set purge type for scoped species/pop/leader</annotation>
        <!--set_purge_type = { country = <target> type = purge_full cooldown = yes }-->
      </complex>
      <complex entity="set_relation_flag" scope="country">
        <annotation>Sets a relation flag for the scoped country towards target country</annotation>
        <!--set_relation_flag = {
	who = <target>
	flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
}-->
      </complex>
      <simple entity="set_ring" type="{bool}" scope="planet">
        <annotation>Adds or removes a planetary ring around the scoped planet</annotation>
      </simple>
      <complex entity="set_saved_date" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Sets an arbitrarily-named date flag for the scoped object. Acts both as an &lt;scope object&gt;_flag and as a means for saving a date. The flag can then be referred to in localisations [This.&lt;flag&gt;] to produce the date</annotation>
        <!--set_saved_date = {
	key = <key> (refer to this in locs; note: this is actually a <country/whatever>_flag)
	days_from_present = <int>/<variable> (time until the date you wish to save)
	expires = <int>/<variable> (time until the saved date is cleared, default is never)
}-->
      </complex>
      <simple entity="set_sector_capital" type="{bool}" scope="planet">
        <annotation>Sets the scoped planet to be the capital of the sector it is part of. If used in the capital sector, it will shift the empire capital. Warning: Experimental, may have unintended consequences</annotation>
      </simple>
      <simple entity="set_sector_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="sector">
        <annotation>Sets an arbitrarily-named flag on the scoped sector</annotation>
      </simple>
      <simple entity="set_sector_focus" type="{sector focus}" scope="sector">
        <annotation>Sets the sector's focus</annotation>
      </simple>
      <simple entity="set_ship_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="ship">
        <annotation>Sets an arbitrarily-named flag on the scoped ship</annotation>
      </simple>
      <simple entity="set_ship_prefix" type="{string}" scope="country">
        <annotation>Sets the ship prefix of the scoped country</annotation>
      </simple>
      <simple entity="set_site_progress_locked" type="{bool}" scope="archaeological_site first_contact">
        <annotation>Locks or unlocks the progress of a site</annotation>
      </simple>
      <simple entity="set_situation_approach" type="{approach (name field of the approach)}" scope="situation">
        <annotation>Sets the approach to the Situation. Respects allow and potential triggers</annotation>
      </simple>
      <simple entity="set_situation_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="situation">
        <annotation>Sets an arbitrarily-named flag on the scoped situation</annotation>
      </simple>
      <simple entity="set_skill" type="{int}" scope="leader">
        <annotation>Sets the scoped leader's level</annotation>
      </simple>
      <complex entity="set_slavery_type" scope="leader pop species">
        <annotation>Set slavery type for scoped species/pop/leader</annotation>
        <!--set_slavery_type = { country = <target> type = slavery_livestock cooldown = yes }-->
      </complex>
      <simple entity="set_spawn_system_batch" type="{should be located in a block between Begin and End. Begin: set_spawn_system_batch = begin End: set_spawn_system_batch = end}">
        <annotation>Optimizes the calls for spawn_system effect</annotation>
      </simple>
      <simple entity="set_species_flag" type="{key (note: one can use key@scope e.g. my_flag@from to track relationships between objects)}" scope="species">
        <annotation>Sets an arbitrarily-named flag on the scoped species</annotation>
      </simple>
      <simple entity="set_species_homeworld" type="{target planet}" scope="species">
        <annotation>Defines a homeworld for the current species</annotation>
      </simple>
      <simple entity="set_species_identity" type="{new/target species}" scope="species">
        <annotation>Sets the current species scopes identity to match the target scopes making them evaluate as the same species in is_same_species trigger</annotation>
      </simple>
      <simple entity="set_spynetwork_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="spy_network">
        <annotation>Sets an arbitrarily-named flag on the scoped spy network</annotation>
      </simple>
      <simple entity="set_star_class" type="{star class}" scope="galactic_object">
        <annotation>Sets the star's star class, affecting system and galactic map graphics and potentially modifiers. Also changes the planet class of the system's primary star</annotation>
      </simple>
      <simple entity="set_star_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="galactic_object">
        <annotation>Sets an arbitrarily-named flag on the scoped system</annotation>
      </simple>
      <complex entity="set_starbase_building" scope="starbase">
        <annotation>Sets a building in a slot on a starbase</annotation>
        <!--set_starbase_building = { slot = <int> building = <starbase_building> }-->
      </complex>
      <simple entity="set_starbase_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="starbase">
        <annotation>Sets an arbitrarily-named flag on the scoped starbase</annotation>
      </simple>
      <complex entity="set_starbase_module" scope="starbase">
        <annotation>Sets a module in a slot on a starbase</annotation>
        <!--set_starbase_module = { slot = <int> module = <starbase_module> }-->
      </complex>
      <simple entity="set_starbase_size" type="{ship_size}" scope="starbase">
        <annotation>Sets the ship size of a starbase</annotation>
      </simple>
      <complex entity="set_subject_of" scope="country">
        <annotation>Sets the scoped country to be a specific subject of target country</annotation>
        <!--set_subject_of = { who = <target> subject_type = <key> }-->
      </complex>
      <complex entity="set_surveyed" scope="galactic_object planet">
        <annotation>Sets the planet or system as un/surveyed by target country</annotation>
        <!--set_surveyed = { surveyed = yes surveyor = <target> }-->
      </complex>
      <complex entity="set_timed_ambient_object_flag" scope="fleet">
        <annotation>Sets an arbitrarily-named flag on the scoped ambient object for a set duration</annotation>
        <!--set_timed_ambient_object_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_archaeology_flag" scope="archaeological_site">
        <annotation>Sets an arbitrarily-named flag on the scoped arc site for a set duration</annotation>
        <!--set_timed_archaeology_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_army_flag" scope="army">
        <annotation>Sets an arbitrarily-named flag on the scoped army for a set duration</annotation>
        <!--set_timed_army_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_country_flag" scope="country">
        <annotation>Sets an arbitrarily-named flag on the scoped country for a set duration</annotation>
        <!--set_timed_country_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_deposit_flag" scope="deposit">
        <annotation>Sets an arbitrarily-named flag on the scoped deposit for a set duration</annotation>
        <!--set_timed_deposit_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_espionage_asset_flag" scope="espionage_asset">
        <annotation>Sets an arbitrarily-named flag on the scoped espionage asset for a set duration</annotation>
        <!--set_timed_espionage_asset_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_espionage_operation_flag" scope="espionage_operation">
        <annotation>Sets an arbitrarily-named flag on the scoped espionage operation for a set duration</annotation>
        <!--set_timed_espionage_operation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_federation_flag" scope="federation">
        <annotation>Sets an arbitrarily-named flag on the scoped federation for a set duration</annotation>
        <!--set_timed_federation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_first_contact_flag" scope="first_contact">
        <annotation>Sets an arbitrarily-named flag on the scoped first contact site for a set duration</annotation>
        <!--set_timed_first_contact_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_fleet_flag" scope="fleet">
        <annotation>Sets an arbitrarily-named flag on the scoped fleet for a set duration</annotation>
        <!--set_timed_fleet_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_global_flag">
        <annotation>Sets an arbitrarily-named global flag for a set duration</annotation>
        <!--set_timed_global_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_leader_flag" scope="leader">
        <annotation>Sets an arbitrarily-named flag on the scoped leader for a set duration</annotation>
        <!--set_timed_leader_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_megastructure_flag" scope="megastructure">
        <annotation>Sets an arbitrarily-named flag on the scoped mega reference for a set duration</annotation>
        <!--set_timed_megastructure_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_planet_flag" scope="planet">
        <annotation>Sets an arbitrarily-named flag on the scoped planet for a set duration</annotation>
        <!--set_timed_planet_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_pop_faction_flag" scope="pop pop_faction">
        <annotation>Sets an arbitrarily-named flag on the scoped pop faction for a set duration</annotation>
        <!--set_timed_pop_faction_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days = <int>
}-->
      </complex>
      <complex entity="set_timed_pop_flag" scope="pop">
        <annotation>Sets an arbitrarily-named flag on the scoped pop for a set duration</annotation>
        <!--set_timed_pop_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_relation_flag" scope="country">
        <annotation>Sets an arbitrarily-named flag for the scoped country towards target country for a set duration</annotation>
        <!--set_timed_relation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	who = <target>
	days/months/years = <int>
}-->
      </complex>
      <complex entity="set_timed_sector_flag" scope="sector">
        <annotation>Sets an arbitrarily-named flag on the scoped sector for a set duration</annotation>
        <!--set_timed_sector_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_ship_flag" scope="ship">
        <annotation>Sets an arbitrarily-named flag on the scoped ship for a set duration</annotation>
        <!--set_timed_ship_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_situation_flag" scope="situation">
        <annotation>Sets an arbitrarily-named flag on the scoped situation for a set duration</annotation>
        <!--set_timed_situation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_species_flag" scope="species">
        <annotation>Sets an arbitrarily-named flag on the scoped species for a set duration</annotation>
        <!--set_timed_species_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_spynetwork_flag" scope="spy_network">
        <annotation>Sets an arbitrarily-named flag on the scoped spy network for a set duration</annotation>
        <!--set_timed_spynetwork_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_star_flag" scope="galactic_object">
        <annotation>Sets an arbitrarily-named flag on the scoped system for a set duration</annotation>
        <!--set_timed_star_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>-->
      </complex>
      <complex entity="set_timed_starbase_flag" scope="starbase">
        <annotation>Sets an arbitrarily-named flag on the scoped starbase for a set duration</annotation>
        <!--set_timed_starbase_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_timed_war_flag" scope="war">
        <annotation>Sets an arbitrarily-named flag on the scoped war for a set duration</annotation>
        <!--set_timed_war_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}-->
      </complex>
      <complex entity="set_truce" scope="country">
        <annotation>Force a truce with target country of a specified type, or a war</annotation>
        <!--set_truce = { target = <country/war> type = war/liberation/alliance/guarantee/none }-->
      </complex>
      <simple entity="set_tutorial_level" type="{int}" scope="country">
        <annotation>Changes the scoped country's tutorial level (0 none, 1 limited, 2 full)</annotation>
      </simple>
      <simple entity="set_update_modifiers_batch" type="{it will trigger a full update of any dirty modifiers. Begin: set_update_modifiers_batch = begin End: set_update_modifiers_batch = end}">
        <annotation>Disables modifier system to do full updates between Begin and End</annotation>
      </simple>
      <complex entity="set_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Sets or creates an arbitrarily-named variable with a specific value in the current scope</annotation>
        <!--set_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }-->
      </complex>
      <simple entity="set_visited" type="{target}" scope="country">
        <annotation>Sets the target system as 'visited' (i.e. low system intel on the map)</annotation>
      </simple>
      <simple entity="set_war_flag" type="{key (note: one can use e.g. my_flag@from to track relationships between objects)}" scope="war">
        <annotation>Sets an arbitrarily-named flag on the scoped war</annotation>
      </simple>
      <complex entity="set_war_goal" scope="country war">
        <annotation>Sets a war goal to the scoped rebel country/war</annotation>
        <!--set_war_goal = { type = <key> target = <target> enemy = <target> }-->
      </complex>
      <simple entity="shift_ethic" type="{key}" scope="country">
        <annotation>Shifts an empire towards a specific ethic, adjusting afterwards to keep number of ethics points consistent</annotation>
      </simple>
      <complex entity="ship_event" scope="ship">
        <annotation>Fires a ship event for the scoped ship, with optional DAYS and RANDOM delay</annotation>
        <!--ship_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="situation_event" scope="situation">
        <annotation>Fires a situation event for the scoped situation</annotation>
        <!--situation_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="spawn_megastructure" scope="galactic_object">
        <annotation>Spawns a mega reference in a system</annotation>
        <!--spawn_megastructure = {
	type = ring_world_ruined
	name = <string>
	owner = <target>
	planet = <planet/star target>
	coords_from = <target> (use this or 'planet' to set the location)
	graphical_culture = <target>
	orbit_distance = 50
	orbit_angle = 50
}-->
      </complex>
      <complex entity="spawn_natural_wormhole" scope="galactic_object">
        <annotation>Spawns a new natural wormhole in the scoped system</annotation>
        <!--spawn_natural_wormhole = { bypass_type = <wormhole/sealed_wormhole> orbit_distance = 100 orbit_angle = 90 random_pos = yes/no }-->
      </complex>
      <simple entity="spawn_planet" scope="galactic_object">
        <annotation>Spawns a planet in a system</annotation>
      </simple>
      <complex entity="spawn_system" scope="fleet galactic_object megastructure no_scope planet ship starbase">
        <annotation>Spawns a new system at a position relative to the scoped system/planet/ship</annotation>
        <!--spawn_system = { min_jumps = <value> max_jumps = <value> min_distance = <int 0-100> max_distance = <int 0-100> initializer = <key for pre-defined system> hyperlane=<yes/no> is_discovered=<yes/no>}-->
      </complex>
      <complex entity="starbase_event" scope="starbase">
        <annotation>Fires a starbase event for the scoped starbase</annotation>
        <!--starbase_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      <complex entity="start_colony" scope="planet">
        <annotation>Starts colonization of the scoped planet</annotation>
        <!--start_colony = {
	owner = <target>
	species = <target / key>
	ethos = <random / target / { ethic = <key> ethic = <key> }>
}-->
      </complex>
      <complex entity="start_situation" scope="country">
        <annotation>Begins a situations</annotation>
        <!--start_situation = { type = <situation_type> target = <scope> }-->
      </complex>
      <complex entity="steal_relic" scope="country">
        <annotation>Steal all/a random/a specific relic from a target country</annotation>
        <!--steal_relic = { target = <Target Country> relic = <relic_name/all/random>-->
      </complex>
      <simple entity="stop_crisis_sound" type="{bool}">
        <annotation>Stops the crisis ambient loop</annotation>
      </simple>
      <complex entity="store_galactic_community_leader_backup_data">
        <annotation>Stores a copy of the specified data of the Galactic Custodian/Emperor. The values default to 'no'</annotation>
        <!--store_galactic_community_leader_backup_data = {
flag = <yes/no>
room = <yes/no>
name = <yes/no
ethics = <yes/no>
government = <yes/no>
}-->
      </complex>
      <complex entity="subtract_variable" scope="ambient_object archaeological_site army country deposit espionage_asset espionage_operation federation first_contact fleet galactic_object leader megastructure planet pop pop_faction sector ship situation species spy_network starbase war">
        <annotation>Decrements a previously-set variable by a specific amount</annotation>
        <!--subtract_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }-->
      </complex>
      <complex entity="switch">
        <annotation>Executes the first appropriate effect set for a specific trigger</annotation>
        <!--switch = {
	trigger = <trigger>
	<corresponding key/bool/int> = { <effect> }
	<corresponding key/bool/int> > (less/greater than appear 'reversed') { <effect> }
	default = { <effect> }
}-->
      </complex>
      <complex entity="system_event" scope="galactic_object">
        <annotation>Fires a system event for the scoped system</annotation>
        <!--system_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}-->
      </complex>
      
      
      
      
      <simple entity="tooltip">
        <annotation>Just a tooltip</annotation>
      </simple>
      <simple entity="transfer_galactic_defense_force_fleets" type="{target}" scope="country">
        <annotation>Moves all owned GDF fleets to the target</annotation>
      </simple>
      <simple entity="trigger_megastructure_icon" scope="planet">
        <annotation>if a planet has trigger_megastructure_icon = yes then the map icon for the star will show a megastructure icon</annotation>
      </simple>
      
      
      
      
      <simple entity="unassign_espionage_asset" type="{esspionage asset type}" scope="espionage_operation">
        <annotation>Unassignes espionage asset from the scope operation to owning spy network</annotation>
      </simple>
      <simple entity="unassign_leader" type="{target}" scope="army fleet leader ship">
        <annotation>Unassigns scoped leader from their post or unassigns leader from the scoped planet/ship/fleet/army</annotation>
      </simple>
      <simple entity="unemploy_pop" type="{bool}" scope="pop">
        <annotation>Fires scoped pop from its job</annotation>
      </simple>
      <simple entity="upgrade_megastructure_to" type="{new_type}" scope="megastructure">
        <annotation>Starts an upgrade process on a mega reference</annotation>
      </simple>
      
      
      
      
      <simple entity="validate_planet_buildings_and_districts" type="{bool}" scope="planet">
        <annotation>Checks whether the planets and districts on the planet are valid (their potential triggers are fulfilled), removes or replaces them if not</annotation>
      </simple>
      
      
      
      
      <complex entity="while">
        <annotation>Repeats enclosed effects while limit criteria are met or until set iteration count is reached</annotation>
        <!--while = { limit = { <complex sequence="only" type="{trigger}" /> } <list sequence="only" type="{effect}" /> }
 while = { count = [3|Variable] <list sequence="only" type="{effect}" /> }-->
      </complex>
      <simple entity="win" type="{bool}" scope="country">
        <annotation>The scoped country wins the game</annotation>
      </simple>
    </choice>
  </reference>
</references>